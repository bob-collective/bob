/**

Generated by the following Solidity interface...
```solidity
interface LightRelay {
    event AuthorizationRequirementChanged(bool newStatus);
    event Genesis(uint256 blockHeight);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event ProofLengthChanged(uint256 newLength);
    event Retarget(uint256 oldDifficulty, uint256 newDifficulty);
    event SubmitterAuthorized(address submitter);
    event SubmitterDeauthorized(address submitter);

    function authorizationRequired() external view returns (bool);
    function authorize(address submitter) external;
    function currentEpoch() external view returns (uint64);
    function deauthorize(address submitter) external;
    function genesis(bytes memory genesisHeader, uint256 genesisHeight, uint64 genesisProofLength) external;
    function genesisEpoch() external view returns (uint64);
    function getBlockDifficulty(uint256 blockNumber) external view returns (uint256);
    function getCurrentAndPrevEpochDifficulty() external view returns (uint256 current, uint256 previous);
    function getCurrentEpochDifficulty() external view returns (uint256);
    function getEpochDifficulty(uint256 epochNumber) external view returns (uint256);
    function getPrevEpochDifficulty() external view returns (uint256);
    function getRelayRange() external view returns (uint256 relayGenesis, uint256 currentEpochEnd);
    function isAuthorized(address) external view returns (bool);
    function owner() external view returns (address);
    function proofLength() external view returns (uint64);
    function ready() external view returns (bool);
    function renounceOwnership() external;
    function retarget(bytes memory headers) external;
    function setAuthorizationStatus(bool status) external;
    function setProofLength(uint64 newLength) external;
    function transferOwnership(address newOwner) external;
    function validateChain(bytes memory headers) external view returns (uint256 startingHeaderTimestamp, uint256 headerCount);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "authorizationRequired",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "authorize",
    "inputs": [
      {
        "name": "submitter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "currentEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "deauthorize",
    "inputs": [
      {
        "name": "submitter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "genesis",
    "inputs": [
      {
        "name": "genesisHeader",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "genesisHeight",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "genesisProofLength",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "genesisEpoch",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockDifficulty",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentAndPrevEpochDifficulty",
    "inputs": [],
    "outputs": [
      {
        "name": "current",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "previous",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getCurrentEpochDifficulty",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getEpochDifficulty",
    "inputs": [
      {
        "name": "epochNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPrevEpochDifficulty",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRelayRange",
    "inputs": [],
    "outputs": [
      {
        "name": "relayGenesis",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "currentEpochEnd",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isAuthorized",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proofLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ready",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "retarget",
    "inputs": [
      {
        "name": "headers",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setAuthorizationStatus",
    "inputs": [
      {
        "name": "status",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProofLength",
    "inputs": [
      {
        "name": "newLength",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "validateChain",
    "inputs": [
      {
        "name": "headers",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "startingHeaderTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "headerCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "AuthorizationRequirementChanged",
    "inputs": [
      {
        "name": "newStatus",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Genesis",
    "inputs": [
      {
        "name": "blockHeight",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProofLengthChanged",
    "inputs": [
      {
        "name": "newLength",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Retarget",
    "inputs": [
      {
        "name": "oldDifficulty",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newDifficulty",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubmitterAuthorized",
    "inputs": [
      {
        "name": "submitter",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubmitterDeauthorized",
    "inputs": [
      {
        "name": "submitter",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod LightRelay {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b50601633601a565b6069565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6124cb806100765f395ff3fe608060405234801561000f575f5ffd5b5060043610610179575f3560e01c8063715018a6116100d2578063b6a5d7de11610088578063f2fde38b11610063578063f2fde38b1461034a578063f5619fda1461035d578063fe9fbb8014610377575f5ffd5b8063b6a5d7de14610310578063b70e6be614610323578063eb8695ef14610337575f5ffd5b80637ca5b1dd116100b85780637ca5b1dd146102b15780638da5cb5b146102c457806395410d2b146102eb575f5ffd5b8063715018a6146102705780637667180814610278575f5ffd5b806327c97fa5116101325780634ca49f511161010d5780634ca49f5114610216578063620414e6146102295780636defbf801461023c575f5ffd5b806327c97fa5146101f05780632b97be24146102035780633a1b77b01461020b575f5ffd5b8063113764be11610162578063113764be146101c0578063189179a3146101c857806319c9aa32146101db575f5ffd5b806306a274221461017d57806310b76ed8146101a3575b5f5ffd5b61019061018b366004612002565b610399565b6040519081526020015b60405180910390f35b6101ab6103af565b6040805192835260208301919091520161019a565b600254610190565b6101ab6101d6366004612046565b610413565b6101ee6101e9366004612152565b610892565b005b6101ee6101fe36600461216b565b610af0565b600354610190565b6002546003546101ab565b6101ee61022436600461219e565b610bd1565b610190610237366004612002565b61102c565b5f546102609074010000000000000000000000000000000000000000900460ff1681565b604051901515815260200161019a565b6101ee611154565b6001546102989068010000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161019a565b6101ee6102bf366004612046565b6111c5565b5f5460405173ffffffffffffffffffffffffffffffffffffffff909116815260200161019a565b5f54610260907501000000000000000000000000000000000000000000900460ff1681565b6101ee61031e36600461216b565b611796565b6001546102989067ffffffffffffffff1681565b6101ee610345366004612223565b61187a565b6101ee61035836600461216b565b611959565b5f5461029890600160b01b900467ffffffffffffffff1681565b61026061038536600461216b565b60056020525f908152604090205460ff1681565b5f6103a96102376107e08461229c565b92915050565b6001545f9081906103cc9067ffffffffffffffff166107e06122af565b60015467ffffffffffffffff91821693506103f79168010000000000000000909104166107e06122af565b610403906107df6122d9565b67ffffffffffffffff1690509091565b5f5f6050835161042391906122f9565b156104755760405162461bcd60e51b815260206004820152601560248201527f496e76616c696420686561646572206c656e677468000000000000000000000060448201526064015b60405180910390fd5b60508351610483919061229c565b905060018111801561049657506107e081105b6104e25760405162461bcd60e51b815260206004820152601960248201527f496e76616c6964206e756d626572206f66206865616465727300000000000000604482015260640161046c565b6104eb83611a54565b63ffffffff1691505f80610500858280611a87565b6040805180820182525f808252602080830182905260015467ffffffffffffffff6801000000000000000090910416808352600482529184902084518086019095525463ffffffff8116855264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690840152939550919350909190825b815163ffffffff168810156105f35761059b60018461230c565b5f8181526004602090815260409182902082518084019093525463ffffffff8116835264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690820152909350919050610581565b815163ffffffff1661066d5760405162461bcd60e51b815260206004820152602b60248201527f43616e6e6f742076616c696461746520636861696e73206265666f726520726560448201527f6c61792067656e65736973000000000000000000000000000000000000000000606482015260840161046c565b81602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1685146107755780602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1685036106c757905082610775565b6106d260018461230c565b5f8181526004602090815260409182902082518084019093525463ffffffff8116835264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690820181905291945092915085146107755760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642074617267657420696e2068656164657220636861696e0000604482015260640161046c565b60015b87811015610886575f6107968b61079084605061231f565b8a611a87565b60208601519098509091507bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16871461087c575f6107db6107d484605061231f565b8d90611b5e565b845163ffffffff91821692501615801590610817575083602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1688145b80156108295750835163ffffffff1681145b6108755760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642074617267657420696e2068656164657220636861696e0000604482015260640161046c565b5091925084915b9650600101610778565b50505050505050915091565b5f5474010000000000000000000000000000000000000000900460ff166108fb5760405162461bcd60e51b815260206004820152601a60248201527f52656c6179206973206e6f7420726561647920666f7220757365000000000000604482015260640161046c565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146109615760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b6107e08167ffffffffffffffff16106109bc5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e6774682065786365737369766500000000000000000000604482015260640161046c565b5f8167ffffffffffffffff1611610a155760405162461bcd60e51b815260206004820152601c60248201527f50726f6f66206c656e677468206d6179206e6f74206265207a65726f00000000604482015260640161046c565b5f5467ffffffffffffffff600160b01b909104811690821603610a7a5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e67746820756e6368616e67656400000000000000000000604482015260640161046c565b5f80547fffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffff16600160b01b67ffffffffffffffff8416908102919091179091556040519081527f3e9f904d8cf11753c79b67c8259c582056d4a7d8af120f81257a59eeb8824b96906020015b60405180910390a150565b5f5473ffffffffffffffffffffffffffffffffffffffff163314610b565760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff81165f8181526005602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905590519182527f7498b96beeabea5ad3139f1a2861a03e480034254e36b10aae2e6e42ad7b4b689101610ae5565b5f5473ffffffffffffffffffffffffffffffffffffffff163314610c375760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b5f5474010000000000000000000000000000000000000000900460ff1615610ca15760405162461bcd60e51b815260206004820152601960248201527f47656e6573697320616c726561647920706572666f726d656400000000000000604482015260640161046c565b60508314610cf15760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642067656e6573697320686561646572206c656e677468000000604482015260640161046c565b610cfd6107e0836122f9565b15610d705760405162461bcd60e51b815260206004820152602560248201527f496e76616c696420686569676874206f662072656c61792067656e657369732060448201527f626c6f636b000000000000000000000000000000000000000000000000000000606482015260840161046c565b6107e08167ffffffffffffffff1610610dcb5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e6774682065786365737369766500000000000000000000604482015260640161046c565b5f8167ffffffffffffffff1611610e245760405162461bcd60e51b815260206004820152601c60248201527f50726f6f66206c656e677468206d6179206e6f74206265207a65726f00000000604482015260640161046c565b610e306107e08361229c565b600180547fffffffffffffffffffffffffffffffff000000000000000000000000000000001667ffffffffffffffff929092169182176801000000000000000092909202919091179055604080516020601f86018190048102820181019092528481525f91610eb9919087908790819084018382808284375f92019190915250611b7e92505050565b90505f610efa86868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611a5492505050565b60408051808201825263ffffffff9283168082527bffffffffffffffffffffffffffffffffffffffffffffffffffffffff808716602080850191825260015467ffffffffffffffff9081165f908152600490925295812094519151909216640100000000029516949094179091558254918616600160b01b027fffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffff909216919091179091559050610fa982611b89565b6002555f80547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16740100000000000000000000000000000000000000001790556040517f2381d16925551c2fb1a5edfcf4fce2f6d085e1f85f4b88340c09c9d191f9d4e99061101c9086815260200190565b60405180910390a1505050505050565b6001545f9067ffffffffffffffff1682101561108a5760405162461bcd60e51b815260206004820152601d60248201527f45706f6368206973206265666f72652072656c61792067656e65736973000000604482015260640161046c565b60015468010000000000000000900467ffffffffffffffff168211156111175760405162461bcd60e51b8152602060048201526024808201527f45706f6368206973206e6f742070726f76656e20746f207468652072656c617960448201527f2079657400000000000000000000000000000000000000000000000000000000606482015260840161046c565b5f828152600460205260409020546103a99064010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16611b89565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146111ba5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b6111c35f611bb0565b565b5f5474010000000000000000000000000000000000000000900460ff1661122e5760405162461bcd60e51b815260206004820152601a60248201527f52656c6179206973206e6f7420726561647920666f7220757365000000000000604482015260640161046c565b5f547501000000000000000000000000000000000000000000900460ff16156112af57335f9081526005602052604090205460ff166112af5760405162461bcd60e51b815260206004820152601660248201527f5375626d697474657220756e617574686f72697a656400000000000000000000604482015260640161046c565b5f546112cd90600160b01b900467ffffffffffffffff1660026122af565b6112d89060506122af565b67ffffffffffffffff168151146113315760405162461bcd60e51b815260206004820152601560248201527f496e76616c696420686561646572206c656e6774680000000000000000000000604482015260640161046c565b60015468010000000000000000900467ffffffffffffffff165f908152600460205260408120805490916401000000009091047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690805b5f54600160b01b900467ffffffffffffffff1681101561143a575f806113b6876113b085605061231f565b86611a87565b9150915084811461142f5760405162461bcd60e51b815260206004820152602660248201527f496e76616c69642074617267657420696e207072652d7265746172676574206860448201527f6561646572730000000000000000000000000000000000000000000000000000606482015260840161046c565b509150600101611385565b505f805461147b9061145f90600190600160b01b900467ffffffffffffffff16612336565b61146a9060506122af565b869067ffffffffffffffff16611b5e565b63ffffffff1690504281106114d25760405162461bcd60e51b815260206004820152601e60248201527f45706f63682063616e6e6f7420656e6420696e20746865206675747572650000604482015260640161046c565b83545f906114e890859063ffffffff1684611c24565b5f80549192509081906115229061151190600160b01b900467ffffffffffffffff1660506122af565b899067ffffffffffffffff16611b5e565b5f5463ffffffff919091169150600160b01b900467ffffffffffffffff165b5f5461155f90600160b01b900467ffffffffffffffff1660026122af565b67ffffffffffffffff16811015611665575f806115818b61079085605061231f565b91509150845f036115e55780945080861681146115e05760405162461bcd60e51b815260206004820152601b60248201527f496e76616c69642074617267657420696e206e65772065706f63680000000000604482015260640161046c565b61165a565b84811461165a5760405162461bcd60e51b815260206004820152602760248201527f556e657870656374656420746172676574206368616e6765206166746572207260448201527f6574617267657400000000000000000000000000000000000000000000000000606482015260840161046c565b509550600101611541565b50600160089054906101000a900467ffffffffffffffff16600161168991906122d9565b6001805467ffffffffffffffff928316680100000000000000009081027fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff909216919091179182905560408051808201825263ffffffff80871682527bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8089166020808501918252959096049096165f908152600490945291832090519351909416640100000000029216919091179091556002549061174484611b89565b6003839055600281905560408051848152602081018390529192507fa282ee798b132f9dc11e06cd4d8e767e562be8709602ca14fea7ab3392acbdab910160405180910390a150505050505050505050565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146117fc5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff81165f8181526005602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905590519182527fd53649b492f738bb59d6825099b5955073efda0bf9e3a7ad20da22e110122e299101610ae5565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146118e05760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b5f80548215157501000000000000000000000000000000000000000000027fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff9091161790556040517fd813b248d49c8bf08be2b6947126da6763df310beed7bea97756456c5727419a90610ae590831515815260200190565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146119bf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff8116611a485760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161046c565b611a5181611bb0565b50565b5f6103a9611a6183611cb6565b60d881901c63ff00ff001662ff00ff60e89290921c9190911617601081811b91901c1790565b5f808215611ae657611a9a858585611cc2565b611ae65760405162461bcd60e51b815260206004820152600d60248201527f496e76616c696420636861696e00000000000000000000000000000000000000604482015260640161046c565b611af08585611ceb565b9050611afe85856050611d88565b9150611b0a8282611dad565b611b565760405162461bcd60e51b815260206004820152600c60248201527f496e76616c696420776f726b0000000000000000000000000000000000000000604482015260640161046c565b935093915050565b5f611b77611a61611b70846044612356565b8590611f03565b9392505050565b5f6103a9825f611ceb565b5f6103a97bffff000000000000000000000000000000000000000000000000000083611f11565b5f805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f80611c308385611f1c565b9050611c40621275006004611f11565b811015611c5857611c55621275006004611f11565b90505b611c66621275006004611f77565b811115611c7e57611c7b621275006004611f77565b90505b5f611c9682611c908862010000611f11565b90611f77565b9050611cac62010000611c908362127500611f11565b9695505050505050565b5f6103a9826044611f03565b5f80611cce8585611fea565b9050828114611ce0575f915050611b77565b506001949350505050565b5f80611cfb611b70846048612356565b60e81c90505f84611d0d85604b612356565b81518110611d1d57611d1d612369565b016020015160f81c90505f611d4f835f60108262ffffff16901c8261ff001660108462ffffff16901b17179050919050565b62ffffff1690505f611d62600384612396565b60ff169050611d738161010061248a565b611d7d908361231f565b979650505050505050565b5f60205f8385602001870160025afa5060205f60205f60025afa50505f519392505050565b5f82611dba57505f6103a9565b81611efb845f8190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b600882901c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff161790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b601082901c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff161790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b602082901c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff1617905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b604082901c77ffffffffffffffff0000000000000000ffffffffffffffff16179050608081901b608082901c179050919050565b109392505050565b5f611b778383016020015190565b5f611b77828461229c565b5f82821115611f6d5760405162461bcd60e51b815260206004820152601d60248201527f556e646572666c6f7720647572696e67207375627472616374696f6e2e000000604482015260640161046c565b611b77828461230c565b5f825f03611f8657505f6103a9565b611f90828461231f565b905081611f9d848361229c565b146103a95760405162461bcd60e51b815260206004820152601f60248201527f4f766572666c6f7720647572696e67206d756c7469706c69636174696f6e2e00604482015260640161046c565b5f611b77611ff9836004612356565b84016020015190565b5f60208284031215612012575f5ffd5b5035919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f60208284031215612056575f5ffd5b813567ffffffffffffffff81111561206c575f5ffd5b8201601f8101841361207c575f5ffd5b803567ffffffffffffffff81111561209657612096612019565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160116810181811067ffffffffffffffff8211171561210257612102612019565b604052818152828201602001861015612119575f5ffd5b816020840160208301375f91810160200191909152949350505050565b803567ffffffffffffffff8116811461214d575f5ffd5b919050565b5f60208284031215612162575f5ffd5b611b7782612136565b5f6020828403121561217b575f5ffd5b813573ffffffffffffffffffffffffffffffffffffffff81168114611b77575f5ffd5b5f5f5f5f606085870312156121b1575f5ffd5b843567ffffffffffffffff8111156121c7575f5ffd5b8501601f810187136121d7575f5ffd5b803567ffffffffffffffff8111156121ed575f5ffd5b8760208284010111156121fe575f5ffd5b602091820195509350850135915061221860408601612136565b905092959194509250565b5f60208284031215612233575f5ffd5b81358015158114611b77575f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f826122aa576122aa612242565b500490565b67ffffffffffffffff81811683821602908116908181146122d2576122d261226f565b5092915050565b67ffffffffffffffff81811683821601908111156103a9576103a961226f565b5f8261230757612307612242565b500690565b818103818111156103a9576103a961226f565b80820281158282048414176103a9576103a961226f565b67ffffffffffffffff82811682821603908111156103a9576103a961226f565b808201808211156103a9576103a961226f565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60ff82811682821603908111156103a9576103a961226f565b6001815b6001841115611b56578085048111156123ce576123ce61226f565b60018416156123dc57908102905b60019390931c9280026123b3565b5f826123f8575060016103a9565b8161240457505f6103a9565b816001811461241a576002811461242457612440565b60019150506103a9565b60ff8411156124355761243561226f565b50506001821b6103a9565b5060208310610133831016604e8410600b8410161715612463575081810a6103a9565b61246f5f1984846123af565b805f19048211156124825761248261226f565b029392505050565b5f611b7783836123ea56fea2646970667358221220fb8619a5a27c76c81c2090ac02dbed1125c3166c28827a8242181a0d91d5aacd64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[P`\x163`\x1AV[`iV[_\x80T`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x01`\x01`\xA0\x1B\x03\x19\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[a$\xCB\x80a\0v_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01yW_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xD2W\x80c\xB6\xA5\xD7\xDE\x11a\0\x88W\x80c\xF2\xFD\xE3\x8B\x11a\0cW\x80c\xF2\xFD\xE3\x8B\x14a\x03JW\x80c\xF5a\x9F\xDA\x14a\x03]W\x80c\xFE\x9F\xBB\x80\x14a\x03wW__\xFD[\x80c\xB6\xA5\xD7\xDE\x14a\x03\x10W\x80c\xB7\x0Ek\xE6\x14a\x03#W\x80c\xEB\x86\x95\xEF\x14a\x037W__\xFD[\x80c|\xA5\xB1\xDD\x11a\0\xB8W\x80c|\xA5\xB1\xDD\x14a\x02\xB1W\x80c\x8D\xA5\xCB[\x14a\x02\xC4W\x80c\x95A\r+\x14a\x02\xEBW__\xFD[\x80cqP\x18\xA6\x14a\x02pW\x80cvg\x18\x08\x14a\x02xW__\xFD[\x80c'\xC9\x7F\xA5\x11a\x012W\x80cL\xA4\x9FQ\x11a\x01\rW\x80cL\xA4\x9FQ\x14a\x02\x16W\x80cb\x04\x14\xE6\x14a\x02)W\x80cm\xEF\xBF\x80\x14a\x02<W__\xFD[\x80c'\xC9\x7F\xA5\x14a\x01\xF0W\x80c+\x97\xBE$\x14a\x02\x03W\x80c:\x1Bw\xB0\x14a\x02\x0BW__\xFD[\x80c\x117d\xBE\x11a\x01bW\x80c\x117d\xBE\x14a\x01\xC0W\x80c\x18\x91y\xA3\x14a\x01\xC8W\x80c\x19\xC9\xAA2\x14a\x01\xDBW__\xFD[\x80c\x06\xA2t\"\x14a\x01}W\x80c\x10\xB7n\xD8\x14a\x01\xA3W[__\xFD[a\x01\x90a\x01\x8B6`\x04a \x02V[a\x03\x99V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xABa\x03\xAFV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\x9AV[`\x02Ta\x01\x90V[a\x01\xABa\x01\xD66`\x04a FV[a\x04\x13V[a\x01\xEEa\x01\xE96`\x04a!RV[a\x08\x92V[\0[a\x01\xEEa\x01\xFE6`\x04a!kV[a\n\xF0V[`\x03Ta\x01\x90V[`\x02T`\x03Ta\x01\xABV[a\x01\xEEa\x02$6`\x04a!\x9EV[a\x0B\xD1V[a\x01\x90a\x0276`\x04a \x02V[a\x10,V[_Ta\x02`\x90t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\x9AV[a\x01\xEEa\x11TV[`\x01Ta\x02\x98\x90h\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x9AV[a\x01\xEEa\x02\xBF6`\x04a FV[a\x11\xC5V[_T`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x9AV[_Ta\x02`\x90u\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x81V[a\x01\xEEa\x03\x1E6`\x04a!kV[a\x17\x96V[`\x01Ta\x02\x98\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x01\xEEa\x03E6`\x04a\"#V[a\x18zV[a\x01\xEEa\x03X6`\x04a!kV[a\x19YV[_Ta\x02\x98\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x02`a\x03\x856`\x04a!kV[`\x05` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[_a\x03\xA9a\x027a\x07\xE0\x84a\"\x9CV[\x92\x91PPV[`\x01T_\x90\x81\x90a\x03\xCC\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xE0a\"\xAFV[`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x93Pa\x03\xF7\x91h\x01\0\0\0\0\0\0\0\0\x90\x91\x04\x16a\x07\xE0a\"\xAFV[a\x04\x03\x90a\x07\xDFa\"\xD9V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90\x91V[__`P\x83Qa\x04#\x91\x90a\"\xF9V[\x15a\x04uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FInvalid header length\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`P\x83Qa\x04\x83\x91\x90a\"\x9CV[\x90P`\x01\x81\x11\x80\x15a\x04\x96WPa\x07\xE0\x81\x10[a\x04\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FInvalid number of headers\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x04\xEB\x83a\x1ATV[c\xFF\xFF\xFF\xFF\x16\x91P_\x80a\x05\0\x85\x82\x80a\x1A\x87V[`@\x80Q\x80\x82\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFh\x01\0\0\0\0\0\0\0\0\x90\x91\x04\x16\x80\x83R`\x04\x82R\x91\x84\x90 \x84Q\x80\x86\x01\x90\x95RTc\xFF\xFF\xFF\xFF\x81\x16\x85Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x84\x01R\x93\x95P\x91\x93P\x90\x91\x90\x82[\x81Qc\xFF\xFF\xFF\xFF\x16\x88\x10\x15a\x05\xF3Wa\x05\x9B`\x01\x84a#\x0CV[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93RTc\xFF\xFF\xFF\xFF\x81\x16\x83Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01R\x90\x93P\x91\x90Pa\x05\x81V[\x81Qc\xFF\xFF\xFF\xFF\x16a\x06mW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FCannot validate chains before re`D\x82\x01R\x7Flay genesis\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[\x81` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85\x14a\x07uW\x80` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85\x03a\x06\xC7W\x90P\x82a\x07uV[a\x06\xD2`\x01\x84a#\x0CV[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93RTc\xFF\xFF\xFF\xFF\x81\x16\x83Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01\x81\x90R\x91\x94P\x92\x91P\x85\x14a\x07uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FInvalid target in header chain\0\0`D\x82\x01R`d\x01a\x04lV[`\x01[\x87\x81\x10\x15a\x08\x86W_a\x07\x96\x8Ba\x07\x90\x84`Pa#\x1FV[\x8Aa\x1A\x87V[` \x86\x01Q\x90\x98P\x90\x91P{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87\x14a\x08|W_a\x07\xDBa\x07\xD4\x84`Pa#\x1FV[\x8D\x90a\x1B^V[\x84Qc\xFF\xFF\xFF\xFF\x91\x82\x16\x92P\x16\x15\x80\x15\x90a\x08\x17WP\x83` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x88\x14[\x80\x15a\x08)WP\x83Qc\xFF\xFF\xFF\xFF\x16\x81\x14[a\x08uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FInvalid target in header chain\0\0`D\x82\x01R`d\x01a\x04lV[P\x91\x92P\x84\x91[\x96P`\x01\x01a\x07xV[PPPPPPP\x91P\x91V[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16a\x08\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FRelay is not ready for use\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\taW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[a\x07\xE0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\t\xBCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length excessive\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\n\x15W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FProof length may not be zero\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xB0\x1B\x90\x91\x04\x81\x16\x90\x82\x16\x03a\nzW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length unchanged\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x80T\x7F\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\xB0\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90\x81\x02\x91\x90\x91\x17\x90\x91U`@Q\x90\x81R\x7F>\x9F\x90M\x8C\xF1\x17S\xC7\x9Bg\xC8%\x9CX V\xD4\xA7\xD8\xAF\x12\x0F\x81%zY\xEE\xB8\x82K\x96\x90` \x01[`@Q\x80\x91\x03\x90\xA1PV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x0BVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x81\x81R`\x05` \x90\x81R`@\x91\x82\x90 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x90U\x90Q\x91\x82R\x7Ft\x98\xB9k\xEE\xAB\xEAZ\xD3\x13\x9F\x1A(a\xA0>H\x004%N6\xB1\n\xAE.nB\xAD{Kh\x91\x01a\n\xE5V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x0C7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15a\x0C\xA1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FGenesis already performed\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[`P\x83\x14a\x0C\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid genesis header length\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x0C\xFDa\x07\xE0\x83a\"\xF9V[\x15a\rpW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`%`$\x82\x01R\x7FInvalid height of relay genesis `D\x82\x01R\x7Fblock\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[a\x07\xE0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\r\xCBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length excessive\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0E$W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FProof length may not be zero\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x0E0a\x07\xE0\x83a\"\x9CV[`\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x82\x17h\x01\0\0\0\0\0\0\0\0\x92\x90\x92\x02\x91\x90\x91\x17\x90U`@\x80Q` `\x1F\x86\x01\x81\x90\x04\x81\x02\x82\x01\x81\x01\x90\x92R\x84\x81R_\x91a\x0E\xB9\x91\x90\x87\x90\x87\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x1B~\x92PPPV[\x90P_a\x0E\xFA\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x1AT\x92PPPV[`@\x80Q\x80\x82\x01\x82Rc\xFF\xFF\xFF\xFF\x92\x83\x16\x80\x82R{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x87\x16` \x80\x85\x01\x91\x82R`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16_\x90\x81R`\x04\x90\x92R\x95\x81 \x94Q\x91Q\x90\x92\x16d\x01\0\0\0\0\x02\x95\x16\x94\x90\x94\x17\x90\x91U\x82T\x91\x86\x16`\x01`\xB0\x1B\x02\x7F\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x90Pa\x0F\xA9\x82a\x1B\x89V[`\x02U_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90U`@Q\x7F#\x81\xD1i%U\x1C/\xB1\xA5\xED\xFC\xF4\xFC\xE2\xF6\xD0\x85\xE1\xF8_K\x884\x0C\t\xC9\xD1\x91\xF9\xD4\xE9\x90a\x10\x1C\x90\x86\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPPPPPV[`\x01T_\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x10\x15a\x10\x8AW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FEpoch is before relay genesis\0\0\0`D\x82\x01R`d\x01a\x04lV[`\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x11\x15a\x11\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FEpoch is not proven to the relay`D\x82\x01R\x7F yet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[_\x82\x81R`\x04` R`@\x90 Ta\x03\xA9\x90d\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B\x89V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x11\xBAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[a\x11\xC3_a\x1B\xB0V[V[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16a\x12.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FRelay is not ready for use\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Tu\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15a\x12\xAFW3_\x90\x81R`\x05` R`@\x90 T`\xFF\x16a\x12\xAFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FSubmitter unauthorized\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Ta\x12\xCD\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02a\"\xAFV[a\x12\xD8\x90`Pa\"\xAFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81Q\x14a\x131W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FInvalid header length\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[`\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x90\x81R`\x04` R`@\x81 \x80T\x90\x91d\x01\0\0\0\0\x90\x91\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80[_T`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a\x14:W_\x80a\x13\xB6\x87a\x13\xB0\x85`Pa#\x1FV[\x86a\x1A\x87V[\x91P\x91P\x84\x81\x14a\x14/W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FInvalid target in pre-retarget h`D\x82\x01R\x7Feaders\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[P\x91P`\x01\x01a\x13\x85V[P_\x80Ta\x14{\x90a\x14_\x90`\x01\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a#6V[a\x14j\x90`Pa\"\xAFV[\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B^V[c\xFF\xFF\xFF\xFF\x16\x90PB\x81\x10a\x14\xD2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FEpoch cannot end in the future\0\0`D\x82\x01R`d\x01a\x04lV[\x83T_\x90a\x14\xE8\x90\x85\x90c\xFF\xFF\xFF\xFF\x16\x84a\x1C$V[_\x80T\x91\x92P\x90\x81\x90a\x15\"\x90a\x15\x11\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`Pa\"\xAFV[\x89\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B^V[_Tc\xFF\xFF\xFF\xFF\x91\x90\x91\x16\x91P`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16[_Ta\x15_\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02a\"\xAFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a\x16eW_\x80a\x15\x81\x8Ba\x07\x90\x85`Pa#\x1FV[\x91P\x91P\x84_\x03a\x15\xE5W\x80\x94P\x80\x86\x16\x81\x14a\x15\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FInvalid target in new epoch\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x16ZV[\x84\x81\x14a\x16ZW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7FUnexpected target change after r`D\x82\x01R\x7Fetarget\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[P\x95P`\x01\x01a\x15AV[P`\x01`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01a\x16\x89\x91\x90a\"\xD9V[`\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16h\x01\0\0\0\0\0\0\0\0\x90\x81\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x91\x82\x90U`@\x80Q\x80\x82\x01\x82Rc\xFF\xFF\xFF\xFF\x80\x87\x16\x82R{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x89\x16` \x80\x85\x01\x91\x82R\x95\x90\x96\x04\x90\x96\x16_\x90\x81R`\x04\x90\x94R\x91\x83 \x90Q\x93Q\x90\x94\x16d\x01\0\0\0\0\x02\x92\x16\x91\x90\x91\x17\x90\x91U`\x02T\x90a\x17D\x84a\x1B\x89V[`\x03\x83\x90U`\x02\x81\x90U`@\x80Q\x84\x81R` \x81\x01\x83\x90R\x91\x92P\x7F\xA2\x82\xEEy\x8B\x13/\x9D\xC1\x1E\x06\xCDM\x8Ev~V+\xE8p\x96\x02\xCA\x14\xFE\xA7\xAB3\x92\xAC\xBD\xAB\x91\x01`@Q\x80\x91\x03\x90\xA1PPPPPPPPPPV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x17\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x81\x81R`\x05` \x90\x81R`@\x91\x82\x90 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U\x90Q\x91\x82R\x7F\xD56I\xB4\x92\xF78\xBBY\xD6\x82P\x99\xB5\x95Ps\xEF\xDA\x0B\xF9\xE3\xA7\xAD \xDA\"\xE1\x10\x12.)\x91\x01a\n\xE5V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x18\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[_\x80T\x82\x15\x15u\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\xD8\x13\xB2H\xD4\x9C\x8B\xF0\x8B\xE2\xB6\x94q&\xDAgc\xDF1\x0B\xEE\xD7\xBE\xA9wVElW'A\x9A\x90a\n\xE5\x90\x83\x15\x15\x81R` \x01\x90V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x19\xBFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x1AHW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FOwnable: new owner is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[a\x1AQ\x81a\x1B\xB0V[PV[_a\x03\xA9a\x1Aa\x83a\x1C\xB6V[`\xD8\x81\x90\x1Cc\xFF\0\xFF\0\x16b\xFF\0\xFF`\xE8\x92\x90\x92\x1C\x91\x90\x91\x16\x17`\x10\x81\x81\x1B\x91\x90\x1C\x17\x90V[_\x80\x82\x15a\x1A\xE6Wa\x1A\x9A\x85\x85\x85a\x1C\xC2V[a\x1A\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FInvalid chain\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x1A\xF0\x85\x85a\x1C\xEBV[\x90Pa\x1A\xFE\x85\x85`Pa\x1D\x88V[\x91Pa\x1B\n\x82\x82a\x1D\xADV[a\x1BVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FInvalid work\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[\x93P\x93\x91PPV[_a\x1Bwa\x1Aaa\x1Bp\x84`Da#VV[\x85\x90a\x1F\x03V[\x93\x92PPPV[_a\x03\xA9\x82_a\x1C\xEBV[_a\x03\xA9{\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1F\x11V[_\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[_\x80a\x1C0\x83\x85a\x1F\x1CV[\x90Pa\x1C@b\x12u\0`\x04a\x1F\x11V[\x81\x10\x15a\x1CXWa\x1CUb\x12u\0`\x04a\x1F\x11V[\x90P[a\x1Cfb\x12u\0`\x04a\x1FwV[\x81\x11\x15a\x1C~Wa\x1C{b\x12u\0`\x04a\x1FwV[\x90P[_a\x1C\x96\x82a\x1C\x90\x88b\x01\0\0a\x1F\x11V[\x90a\x1FwV[\x90Pa\x1C\xACb\x01\0\0a\x1C\x90\x83b\x12u\0a\x1F\x11V[\x96\x95PPPPPPV[_a\x03\xA9\x82`Da\x1F\x03V[_\x80a\x1C\xCE\x85\x85a\x1F\xEAV[\x90P\x82\x81\x14a\x1C\xE0W_\x91PPa\x1BwV[P`\x01\x94\x93PPPPV[_\x80a\x1C\xFBa\x1Bp\x84`Ha#VV[`\xE8\x1C\x90P_\x84a\x1D\r\x85`Ka#VV[\x81Q\x81\x10a\x1D\x1DWa\x1D\x1Da#iV[\x01` \x01Q`\xF8\x1C\x90P_a\x1DO\x83_`\x10\x82b\xFF\xFF\xFF\x16\x90\x1C\x82a\xFF\0\x16`\x10\x84b\xFF\xFF\xFF\x16\x90\x1B\x17\x17\x90P\x91\x90PV[b\xFF\xFF\xFF\x16\x90P_a\x1Db`\x03\x84a#\x96V[`\xFF\x16\x90Pa\x1Ds\x81a\x01\0a$\x8AV[a\x1D}\x90\x83a#\x1FV[\x97\x96PPPPPPPV[_` _\x83\x85` \x01\x87\x01`\x02Z\xFAP` _` _`\x02Z\xFAPP_Q\x93\x92PPPV[_\x82a\x1D\xBAWP_a\x03\xA9V[\x81a\x1E\xFB\x84_\x81\x90P`\x08\x81~\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\x16\x90\x1B`\x08\x82\x90\x1C~\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\x16\x17\x90P`\x10\x81}\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\x16\x90\x1B`\x10\x82\x90\x1C}\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\x16\x17\x90P` \x81{\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\x16\x90\x1B` \x82\x90\x1C{\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\x16\x17\x90P`@\x81w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x1B`@\x82\x90\x1Cw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90P`\x80\x81\x90\x1B`\x80\x82\x90\x1C\x17\x90P\x91\x90PV[\x10\x93\x92PPPV[_a\x1Bw\x83\x83\x01` \x01Q\x90V[_a\x1Bw\x82\x84a\"\x9CV[_\x82\x82\x11\x15a\x1FmW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FUnderflow during subtraction.\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x1Bw\x82\x84a#\x0CV[_\x82_\x03a\x1F\x86WP_a\x03\xA9V[a\x1F\x90\x82\x84a#\x1FV[\x90P\x81a\x1F\x9D\x84\x83a\"\x9CV[\x14a\x03\xA9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FOverflow during multiplication.\0`D\x82\x01R`d\x01a\x04lV[_a\x1Bwa\x1F\xF9\x83`\x04a#VV[\x84\x01` \x01Q\x90V[_` \x82\x84\x03\x12\x15a \x12W__\xFD[P5\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a VW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a lW__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a |W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x96Wa \x96a \x19V[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x85\x01\x16\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a!\x02Wa!\x02a \x19V[`@R\x81\x81R\x82\x82\x01` \x01\x86\x10\x15a!\x19W__\xFD[\x81` \x84\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a!MW__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a!bW__\xFD[a\x1Bw\x82a!6V[_` \x82\x84\x03\x12\x15a!{W__\xFD[\x815s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x1BwW__\xFD[____``\x85\x87\x03\x12\x15a!\xB1W__\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xC7W__\xFD[\x85\x01`\x1F\x81\x01\x87\x13a!\xD7W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xEDW__\xFD[\x87` \x82\x84\x01\x01\x11\x15a!\xFEW__\xFD[` \x91\x82\x01\x95P\x93P\x85\x015\x91Pa\"\x18`@\x86\x01a!6V[\x90P\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\"3W__\xFD[\x815\x80\x15\x15\x81\x14a\x1BwW__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_\x82a\"\xAAWa\"\xAAa\"BV[P\x04\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x02\x90\x81\x16\x90\x81\x81\x14a\"\xD2Wa\"\xD2a\"oV[P\x92\x91PPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[_\x82a#\x07Wa#\x07a\"BV[P\x06\x90V[\x81\x81\x03\x81\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\xA9Wa\x03\xA9a\"oV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x80\x82\x01\x80\x82\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[`\x01\x81[`\x01\x84\x11\x15a\x1BVW\x80\x85\x04\x81\x11\x15a#\xCEWa#\xCEa\"oV[`\x01\x84\x16\x15a#\xDCW\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a#\xB3V[_\x82a#\xF8WP`\x01a\x03\xA9V[\x81a$\x04WP_a\x03\xA9V[\x81`\x01\x81\x14a$\x1AW`\x02\x81\x14a$$Wa$@V[`\x01\x91PPa\x03\xA9V[`\xFF\x84\x11\x15a$5Wa$5a\"oV[PP`\x01\x82\x1Ba\x03\xA9V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a$cWP\x81\x81\na\x03\xA9V[a$o_\x19\x84\x84a#\xAFV[\x80_\x19\x04\x82\x11\x15a$\x82Wa$\x82a\"oV[\x02\x93\x92PPPV[_a\x1Bw\x83\x83a#\xEAV\xFE\xA2dipfsX\"\x12 \xFB\x86\x19\xA5\xA2|v\xC8\x1C \x90\xAC\x02\xDB\xED\x11%\xC3\x16l(\x82z\x82B\x18\x1A\r\x91\xD5\xAA\xCDdsolcC\0\x08\x1B\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610179575f3560e01c8063715018a6116100d2578063b6a5d7de11610088578063f2fde38b11610063578063f2fde38b1461034a578063f5619fda1461035d578063fe9fbb8014610377575f5ffd5b8063b6a5d7de14610310578063b70e6be614610323578063eb8695ef14610337575f5ffd5b80637ca5b1dd116100b85780637ca5b1dd146102b15780638da5cb5b146102c457806395410d2b146102eb575f5ffd5b8063715018a6146102705780637667180814610278575f5ffd5b806327c97fa5116101325780634ca49f511161010d5780634ca49f5114610216578063620414e6146102295780636defbf801461023c575f5ffd5b806327c97fa5146101f05780632b97be24146102035780633a1b77b01461020b575f5ffd5b8063113764be11610162578063113764be146101c0578063189179a3146101c857806319c9aa32146101db575f5ffd5b806306a274221461017d57806310b76ed8146101a3575b5f5ffd5b61019061018b366004612002565b610399565b6040519081526020015b60405180910390f35b6101ab6103af565b6040805192835260208301919091520161019a565b600254610190565b6101ab6101d6366004612046565b610413565b6101ee6101e9366004612152565b610892565b005b6101ee6101fe36600461216b565b610af0565b600354610190565b6002546003546101ab565b6101ee61022436600461219e565b610bd1565b610190610237366004612002565b61102c565b5f546102609074010000000000000000000000000000000000000000900460ff1681565b604051901515815260200161019a565b6101ee611154565b6001546102989068010000000000000000900467ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161019a565b6101ee6102bf366004612046565b6111c5565b5f5460405173ffffffffffffffffffffffffffffffffffffffff909116815260200161019a565b5f54610260907501000000000000000000000000000000000000000000900460ff1681565b6101ee61031e36600461216b565b611796565b6001546102989067ffffffffffffffff1681565b6101ee610345366004612223565b61187a565b6101ee61035836600461216b565b611959565b5f5461029890600160b01b900467ffffffffffffffff1681565b61026061038536600461216b565b60056020525f908152604090205460ff1681565b5f6103a96102376107e08461229c565b92915050565b6001545f9081906103cc9067ffffffffffffffff166107e06122af565b60015467ffffffffffffffff91821693506103f79168010000000000000000909104166107e06122af565b610403906107df6122d9565b67ffffffffffffffff1690509091565b5f5f6050835161042391906122f9565b156104755760405162461bcd60e51b815260206004820152601560248201527f496e76616c696420686561646572206c656e677468000000000000000000000060448201526064015b60405180910390fd5b60508351610483919061229c565b905060018111801561049657506107e081105b6104e25760405162461bcd60e51b815260206004820152601960248201527f496e76616c6964206e756d626572206f66206865616465727300000000000000604482015260640161046c565b6104eb83611a54565b63ffffffff1691505f80610500858280611a87565b6040805180820182525f808252602080830182905260015467ffffffffffffffff6801000000000000000090910416808352600482529184902084518086019095525463ffffffff8116855264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690840152939550919350909190825b815163ffffffff168810156105f35761059b60018461230c565b5f8181526004602090815260409182902082518084019093525463ffffffff8116835264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690820152909350919050610581565b815163ffffffff1661066d5760405162461bcd60e51b815260206004820152602b60248201527f43616e6e6f742076616c696461746520636861696e73206265666f726520726560448201527f6c61792067656e65736973000000000000000000000000000000000000000000606482015260840161046c565b81602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1685146107755780602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1685036106c757905082610775565b6106d260018461230c565b5f8181526004602090815260409182902082518084019093525463ffffffff8116835264010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690820181905291945092915085146107755760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642074617267657420696e2068656164657220636861696e0000604482015260640161046c565b60015b87811015610886575f6107968b61079084605061231f565b8a611a87565b60208601519098509091507bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16871461087c575f6107db6107d484605061231f565b8d90611b5e565b845163ffffffff91821692501615801590610817575083602001517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1688145b80156108295750835163ffffffff1681145b6108755760405162461bcd60e51b815260206004820152601e60248201527f496e76616c69642074617267657420696e2068656164657220636861696e0000604482015260640161046c565b5091925084915b9650600101610778565b50505050505050915091565b5f5474010000000000000000000000000000000000000000900460ff166108fb5760405162461bcd60e51b815260206004820152601a60248201527f52656c6179206973206e6f7420726561647920666f7220757365000000000000604482015260640161046c565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146109615760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b6107e08167ffffffffffffffff16106109bc5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e6774682065786365737369766500000000000000000000604482015260640161046c565b5f8167ffffffffffffffff1611610a155760405162461bcd60e51b815260206004820152601c60248201527f50726f6f66206c656e677468206d6179206e6f74206265207a65726f00000000604482015260640161046c565b5f5467ffffffffffffffff600160b01b909104811690821603610a7a5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e67746820756e6368616e67656400000000000000000000604482015260640161046c565b5f80547fffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffff16600160b01b67ffffffffffffffff8416908102919091179091556040519081527f3e9f904d8cf11753c79b67c8259c582056d4a7d8af120f81257a59eeb8824b96906020015b60405180910390a150565b5f5473ffffffffffffffffffffffffffffffffffffffff163314610b565760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff81165f8181526005602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905590519182527f7498b96beeabea5ad3139f1a2861a03e480034254e36b10aae2e6e42ad7b4b689101610ae5565b5f5473ffffffffffffffffffffffffffffffffffffffff163314610c375760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b5f5474010000000000000000000000000000000000000000900460ff1615610ca15760405162461bcd60e51b815260206004820152601960248201527f47656e6573697320616c726561647920706572666f726d656400000000000000604482015260640161046c565b60508314610cf15760405162461bcd60e51b815260206004820152601d60248201527f496e76616c69642067656e6573697320686561646572206c656e677468000000604482015260640161046c565b610cfd6107e0836122f9565b15610d705760405162461bcd60e51b815260206004820152602560248201527f496e76616c696420686569676874206f662072656c61792067656e657369732060448201527f626c6f636b000000000000000000000000000000000000000000000000000000606482015260840161046c565b6107e08167ffffffffffffffff1610610dcb5760405162461bcd60e51b815260206004820152601660248201527f50726f6f66206c656e6774682065786365737369766500000000000000000000604482015260640161046c565b5f8167ffffffffffffffff1611610e245760405162461bcd60e51b815260206004820152601c60248201527f50726f6f66206c656e677468206d6179206e6f74206265207a65726f00000000604482015260640161046c565b610e306107e08361229c565b600180547fffffffffffffffffffffffffffffffff000000000000000000000000000000001667ffffffffffffffff929092169182176801000000000000000092909202919091179055604080516020601f86018190048102820181019092528481525f91610eb9919087908790819084018382808284375f92019190915250611b7e92505050565b90505f610efa86868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611a5492505050565b60408051808201825263ffffffff9283168082527bffffffffffffffffffffffffffffffffffffffffffffffffffffffff808716602080850191825260015467ffffffffffffffff9081165f908152600490925295812094519151909216640100000000029516949094179091558254918616600160b01b027fffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffff909216919091179091559050610fa982611b89565b6002555f80547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16740100000000000000000000000000000000000000001790556040517f2381d16925551c2fb1a5edfcf4fce2f6d085e1f85f4b88340c09c9d191f9d4e99061101c9086815260200190565b60405180910390a1505050505050565b6001545f9067ffffffffffffffff1682101561108a5760405162461bcd60e51b815260206004820152601d60248201527f45706f6368206973206265666f72652072656c61792067656e65736973000000604482015260640161046c565b60015468010000000000000000900467ffffffffffffffff168211156111175760405162461bcd60e51b8152602060048201526024808201527f45706f6368206973206e6f742070726f76656e20746f207468652072656c617960448201527f2079657400000000000000000000000000000000000000000000000000000000606482015260840161046c565b5f828152600460205260409020546103a99064010000000090047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16611b89565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146111ba5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b6111c35f611bb0565b565b5f5474010000000000000000000000000000000000000000900460ff1661122e5760405162461bcd60e51b815260206004820152601a60248201527f52656c6179206973206e6f7420726561647920666f7220757365000000000000604482015260640161046c565b5f547501000000000000000000000000000000000000000000900460ff16156112af57335f9081526005602052604090205460ff166112af5760405162461bcd60e51b815260206004820152601660248201527f5375626d697474657220756e617574686f72697a656400000000000000000000604482015260640161046c565b5f546112cd90600160b01b900467ffffffffffffffff1660026122af565b6112d89060506122af565b67ffffffffffffffff168151146113315760405162461bcd60e51b815260206004820152601560248201527f496e76616c696420686561646572206c656e6774680000000000000000000000604482015260640161046c565b60015468010000000000000000900467ffffffffffffffff165f908152600460205260408120805490916401000000009091047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690805b5f54600160b01b900467ffffffffffffffff1681101561143a575f806113b6876113b085605061231f565b86611a87565b9150915084811461142f5760405162461bcd60e51b815260206004820152602660248201527f496e76616c69642074617267657420696e207072652d7265746172676574206860448201527f6561646572730000000000000000000000000000000000000000000000000000606482015260840161046c565b509150600101611385565b505f805461147b9061145f90600190600160b01b900467ffffffffffffffff16612336565b61146a9060506122af565b869067ffffffffffffffff16611b5e565b63ffffffff1690504281106114d25760405162461bcd60e51b815260206004820152601e60248201527f45706f63682063616e6e6f7420656e6420696e20746865206675747572650000604482015260640161046c565b83545f906114e890859063ffffffff1684611c24565b5f80549192509081906115229061151190600160b01b900467ffffffffffffffff1660506122af565b899067ffffffffffffffff16611b5e565b5f5463ffffffff919091169150600160b01b900467ffffffffffffffff165b5f5461155f90600160b01b900467ffffffffffffffff1660026122af565b67ffffffffffffffff16811015611665575f806115818b61079085605061231f565b91509150845f036115e55780945080861681146115e05760405162461bcd60e51b815260206004820152601b60248201527f496e76616c69642074617267657420696e206e65772065706f63680000000000604482015260640161046c565b61165a565b84811461165a5760405162461bcd60e51b815260206004820152602760248201527f556e657870656374656420746172676574206368616e6765206166746572207260448201527f6574617267657400000000000000000000000000000000000000000000000000606482015260840161046c565b509550600101611541565b50600160089054906101000a900467ffffffffffffffff16600161168991906122d9565b6001805467ffffffffffffffff928316680100000000000000009081027fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff909216919091179182905560408051808201825263ffffffff80871682527bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8089166020808501918252959096049096165f908152600490945291832090519351909416640100000000029216919091179091556002549061174484611b89565b6003839055600281905560408051848152602081018390529192507fa282ee798b132f9dc11e06cd4d8e767e562be8709602ca14fea7ab3392acbdab910160405180910390a150505050505050505050565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146117fc5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff81165f8181526005602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905590519182527fd53649b492f738bb59d6825099b5955073efda0bf9e3a7ad20da22e110122e299101610ae5565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146118e05760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b5f80548215157501000000000000000000000000000000000000000000027fffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffffff9091161790556040517fd813b248d49c8bf08be2b6947126da6763df310beed7bea97756456c5727419a90610ae590831515815260200190565b5f5473ffffffffffffffffffffffffffffffffffffffff1633146119bf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161046c565b73ffffffffffffffffffffffffffffffffffffffff8116611a485760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161046c565b611a5181611bb0565b50565b5f6103a9611a6183611cb6565b60d881901c63ff00ff001662ff00ff60e89290921c9190911617601081811b91901c1790565b5f808215611ae657611a9a858585611cc2565b611ae65760405162461bcd60e51b815260206004820152600d60248201527f496e76616c696420636861696e00000000000000000000000000000000000000604482015260640161046c565b611af08585611ceb565b9050611afe85856050611d88565b9150611b0a8282611dad565b611b565760405162461bcd60e51b815260206004820152600c60248201527f496e76616c696420776f726b0000000000000000000000000000000000000000604482015260640161046c565b935093915050565b5f611b77611a61611b70846044612356565b8590611f03565b9392505050565b5f6103a9825f611ceb565b5f6103a97bffff000000000000000000000000000000000000000000000000000083611f11565b5f805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f80611c308385611f1c565b9050611c40621275006004611f11565b811015611c5857611c55621275006004611f11565b90505b611c66621275006004611f77565b811115611c7e57611c7b621275006004611f77565b90505b5f611c9682611c908862010000611f11565b90611f77565b9050611cac62010000611c908362127500611f11565b9695505050505050565b5f6103a9826044611f03565b5f80611cce8585611fea565b9050828114611ce0575f915050611b77565b506001949350505050565b5f80611cfb611b70846048612356565b60e81c90505f84611d0d85604b612356565b81518110611d1d57611d1d612369565b016020015160f81c90505f611d4f835f60108262ffffff16901c8261ff001660108462ffffff16901b17179050919050565b62ffffff1690505f611d62600384612396565b60ff169050611d738161010061248a565b611d7d908361231f565b979650505050505050565b5f60205f8385602001870160025afa5060205f60205f60025afa50505f519392505050565b5f82611dba57505f6103a9565b81611efb845f8190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b600882901c7eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff161790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b601082901c7dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff161790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b602082901c7bffffffff00000000ffffffff00000000ffffffff00000000ffffffff1617905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b604082901c77ffffffffffffffff0000000000000000ffffffffffffffff16179050608081901b608082901c179050919050565b109392505050565b5f611b778383016020015190565b5f611b77828461229c565b5f82821115611f6d5760405162461bcd60e51b815260206004820152601d60248201527f556e646572666c6f7720647572696e67207375627472616374696f6e2e000000604482015260640161046c565b611b77828461230c565b5f825f03611f8657505f6103a9565b611f90828461231f565b905081611f9d848361229c565b146103a95760405162461bcd60e51b815260206004820152601f60248201527f4f766572666c6f7720647572696e67206d756c7469706c69636174696f6e2e00604482015260640161046c565b5f611b77611ff9836004612356565b84016020015190565b5f60208284031215612012575f5ffd5b5035919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b5f60208284031215612056575f5ffd5b813567ffffffffffffffff81111561206c575f5ffd5b8201601f8101841361207c575f5ffd5b803567ffffffffffffffff81111561209657612096612019565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160116810181811067ffffffffffffffff8211171561210257612102612019565b604052818152828201602001861015612119575f5ffd5b816020840160208301375f91810160200191909152949350505050565b803567ffffffffffffffff8116811461214d575f5ffd5b919050565b5f60208284031215612162575f5ffd5b611b7782612136565b5f6020828403121561217b575f5ffd5b813573ffffffffffffffffffffffffffffffffffffffff81168114611b77575f5ffd5b5f5f5f5f606085870312156121b1575f5ffd5b843567ffffffffffffffff8111156121c7575f5ffd5b8501601f810187136121d7575f5ffd5b803567ffffffffffffffff8111156121ed575f5ffd5b8760208284010111156121fe575f5ffd5b602091820195509350850135915061221860408601612136565b905092959194509250565b5f60208284031215612233575f5ffd5b81358015158114611b77575f5ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f826122aa576122aa612242565b500490565b67ffffffffffffffff81811683821602908116908181146122d2576122d261226f565b5092915050565b67ffffffffffffffff81811683821601908111156103a9576103a961226f565b5f8261230757612307612242565b500690565b818103818111156103a9576103a961226f565b80820281158282048414176103a9576103a961226f565b67ffffffffffffffff82811682821603908111156103a9576103a961226f565b808201808211156103a9576103a961226f565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b60ff82811682821603908111156103a9576103a961226f565b6001815b6001841115611b56578085048111156123ce576123ce61226f565b60018416156123dc57908102905b60019390931c9280026123b3565b5f826123f8575060016103a9565b8161240457505f6103a9565b816001811461241a576002811461242457612440565b60019150506103a9565b60ff8411156124355761243561226f565b50506001821b6103a9565b5060208310610133831016604e8410600b8410161715612463575081810a6103a9565b61246f5f1984846123af565b805f19048211156124825761248261226f565b029392505050565b5f611b7783836123ea56fea2646970667358221220fb8619a5a27c76c81c2090ac02dbed1125c3166c28827a8242181a0d91d5aacd64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01yW_5`\xE0\x1C\x80cqP\x18\xA6\x11a\0\xD2W\x80c\xB6\xA5\xD7\xDE\x11a\0\x88W\x80c\xF2\xFD\xE3\x8B\x11a\0cW\x80c\xF2\xFD\xE3\x8B\x14a\x03JW\x80c\xF5a\x9F\xDA\x14a\x03]W\x80c\xFE\x9F\xBB\x80\x14a\x03wW__\xFD[\x80c\xB6\xA5\xD7\xDE\x14a\x03\x10W\x80c\xB7\x0Ek\xE6\x14a\x03#W\x80c\xEB\x86\x95\xEF\x14a\x037W__\xFD[\x80c|\xA5\xB1\xDD\x11a\0\xB8W\x80c|\xA5\xB1\xDD\x14a\x02\xB1W\x80c\x8D\xA5\xCB[\x14a\x02\xC4W\x80c\x95A\r+\x14a\x02\xEBW__\xFD[\x80cqP\x18\xA6\x14a\x02pW\x80cvg\x18\x08\x14a\x02xW__\xFD[\x80c'\xC9\x7F\xA5\x11a\x012W\x80cL\xA4\x9FQ\x11a\x01\rW\x80cL\xA4\x9FQ\x14a\x02\x16W\x80cb\x04\x14\xE6\x14a\x02)W\x80cm\xEF\xBF\x80\x14a\x02<W__\xFD[\x80c'\xC9\x7F\xA5\x14a\x01\xF0W\x80c+\x97\xBE$\x14a\x02\x03W\x80c:\x1Bw\xB0\x14a\x02\x0BW__\xFD[\x80c\x117d\xBE\x11a\x01bW\x80c\x117d\xBE\x14a\x01\xC0W\x80c\x18\x91y\xA3\x14a\x01\xC8W\x80c\x19\xC9\xAA2\x14a\x01\xDBW__\xFD[\x80c\x06\xA2t\"\x14a\x01}W\x80c\x10\xB7n\xD8\x14a\x01\xA3W[__\xFD[a\x01\x90a\x01\x8B6`\x04a \x02V[a\x03\x99V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x01\xABa\x03\xAFV[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\x9AV[`\x02Ta\x01\x90V[a\x01\xABa\x01\xD66`\x04a FV[a\x04\x13V[a\x01\xEEa\x01\xE96`\x04a!RV[a\x08\x92V[\0[a\x01\xEEa\x01\xFE6`\x04a!kV[a\n\xF0V[`\x03Ta\x01\x90V[`\x02T`\x03Ta\x01\xABV[a\x01\xEEa\x02$6`\x04a!\x9EV[a\x0B\xD1V[a\x01\x90a\x0276`\x04a \x02V[a\x10,V[_Ta\x02`\x90t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x01\x9AV[a\x01\xEEa\x11TV[`\x01Ta\x02\x98\x90h\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[`@Qg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x9AV[a\x01\xEEa\x02\xBF6`\x04a FV[a\x11\xC5V[_T`@Qs\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\x9AV[_Ta\x02`\x90u\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x81V[a\x01\xEEa\x03\x1E6`\x04a!kV[a\x17\x96V[`\x01Ta\x02\x98\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x01\xEEa\x03E6`\x04a\"#V[a\x18zV[a\x01\xEEa\x03X6`\x04a!kV[a\x19YV[_Ta\x02\x98\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81V[a\x02`a\x03\x856`\x04a!kV[`\x05` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[_a\x03\xA9a\x027a\x07\xE0\x84a\"\x9CV[\x92\x91PPV[`\x01T_\x90\x81\x90a\x03\xCC\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x07\xE0a\"\xAFV[`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x91\x82\x16\x93Pa\x03\xF7\x91h\x01\0\0\0\0\0\0\0\0\x90\x91\x04\x16a\x07\xE0a\"\xAFV[a\x04\x03\x90a\x07\xDFa\"\xD9V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90P\x90\x91V[__`P\x83Qa\x04#\x91\x90a\"\xF9V[\x15a\x04uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FInvalid header length\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01[`@Q\x80\x91\x03\x90\xFD[`P\x83Qa\x04\x83\x91\x90a\"\x9CV[\x90P`\x01\x81\x11\x80\x15a\x04\x96WPa\x07\xE0\x81\x10[a\x04\xE2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FInvalid number of headers\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x04\xEB\x83a\x1ATV[c\xFF\xFF\xFF\xFF\x16\x91P_\x80a\x05\0\x85\x82\x80a\x1A\x87V[`@\x80Q\x80\x82\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFh\x01\0\0\0\0\0\0\0\0\x90\x91\x04\x16\x80\x83R`\x04\x82R\x91\x84\x90 \x84Q\x80\x86\x01\x90\x95RTc\xFF\xFF\xFF\xFF\x81\x16\x85Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x84\x01R\x93\x95P\x91\x93P\x90\x91\x90\x82[\x81Qc\xFF\xFF\xFF\xFF\x16\x88\x10\x15a\x05\xF3Wa\x05\x9B`\x01\x84a#\x0CV[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93RTc\xFF\xFF\xFF\xFF\x81\x16\x83Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01R\x90\x93P\x91\x90Pa\x05\x81V[\x81Qc\xFF\xFF\xFF\xFF\x16a\x06mW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7FCannot validate chains before re`D\x82\x01R\x7Flay genesis\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[\x81` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85\x14a\x07uW\x80` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x85\x03a\x06\xC7W\x90P\x82a\x07uV[a\x06\xD2`\x01\x84a#\x0CV[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93RTc\xFF\xFF\xFF\xFF\x81\x16\x83Rd\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x82\x01\x81\x90R\x91\x94P\x92\x91P\x85\x14a\x07uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FInvalid target in header chain\0\0`D\x82\x01R`d\x01a\x04lV[`\x01[\x87\x81\x10\x15a\x08\x86W_a\x07\x96\x8Ba\x07\x90\x84`Pa#\x1FV[\x8Aa\x1A\x87V[` \x86\x01Q\x90\x98P\x90\x91P{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x87\x14a\x08|W_a\x07\xDBa\x07\xD4\x84`Pa#\x1FV[\x8D\x90a\x1B^V[\x84Qc\xFF\xFF\xFF\xFF\x91\x82\x16\x92P\x16\x15\x80\x15\x90a\x08\x17WP\x83` \x01Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x88\x14[\x80\x15a\x08)WP\x83Qc\xFF\xFF\xFF\xFF\x16\x81\x14[a\x08uW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FInvalid target in header chain\0\0`D\x82\x01R`d\x01a\x04lV[P\x91\x92P\x84\x91[\x96P`\x01\x01a\x07xV[PPPPPPP\x91P\x91V[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16a\x08\xFBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FRelay is not ready for use\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\taW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[a\x07\xE0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\t\xBCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length excessive\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\n\x15W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FProof length may not be zero\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x01`\xB0\x1B\x90\x91\x04\x81\x16\x90\x82\x16\x03a\nzW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length unchanged\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x80T\x7F\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01`\xB0\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x16\x90\x81\x02\x91\x90\x91\x17\x90\x91U`@Q\x90\x81R\x7F>\x9F\x90M\x8C\xF1\x17S\xC7\x9Bg\xC8%\x9CX V\xD4\xA7\xD8\xAF\x12\x0F\x81%zY\xEE\xB8\x82K\x96\x90` \x01[`@Q\x80\x91\x03\x90\xA1PV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x0BVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x81\x81R`\x05` \x90\x81R`@\x91\x82\x90 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16\x90U\x90Q\x91\x82R\x7Ft\x98\xB9k\xEE\xAB\xEAZ\xD3\x13\x9F\x1A(a\xA0>H\x004%N6\xB1\n\xAE.nB\xAD{Kh\x91\x01a\n\xE5V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x0C7W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15a\x0C\xA1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x19`$\x82\x01R\x7FGenesis already performed\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[`P\x83\x14a\x0C\xF1W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FInvalid genesis header length\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x0C\xFDa\x07\xE0\x83a\"\xF9V[\x15a\rpW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`%`$\x82\x01R\x7FInvalid height of relay genesis `D\x82\x01R\x7Fblock\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[a\x07\xE0\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x10a\r\xCBW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FProof length excessive\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x11a\x0E$W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1C`$\x82\x01R\x7FProof length may not be zero\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x0E0a\x07\xE0\x83a\"\x9CV[`\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x90\x92\x16\x91\x82\x17h\x01\0\0\0\0\0\0\0\0\x92\x90\x92\x02\x91\x90\x91\x17\x90U`@\x80Q` `\x1F\x86\x01\x81\x90\x04\x81\x02\x82\x01\x81\x01\x90\x92R\x84\x81R_\x91a\x0E\xB9\x91\x90\x87\x90\x87\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x1B~\x92PPPV[\x90P_a\x0E\xFA\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa\x1AT\x92PPPV[`@\x80Q\x80\x82\x01\x82Rc\xFF\xFF\xFF\xFF\x92\x83\x16\x80\x82R{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x87\x16` \x80\x85\x01\x91\x82R`\x01Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x81\x16_\x90\x81R`\x04\x90\x92R\x95\x81 \x94Q\x91Q\x90\x92\x16d\x01\0\0\0\0\x02\x95\x16\x94\x90\x94\x17\x90\x91U\x82T\x91\x86\x16`\x01`\xB0\x1B\x02\x7F\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x90\x91U\x90Pa\x0F\xA9\x82a\x1B\x89V[`\x02U_\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16t\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x17\x90U`@Q\x7F#\x81\xD1i%U\x1C/\xB1\xA5\xED\xFC\xF4\xFC\xE2\xF6\xD0\x85\xE1\xF8_K\x884\x0C\t\xC9\xD1\x91\xF9\xD4\xE9\x90a\x10\x1C\x90\x86\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA1PPPPPPV[`\x01T_\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x10\x15a\x10\x8AW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FEpoch is before relay genesis\0\0\0`D\x82\x01R`d\x01a\x04lV[`\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x82\x11\x15a\x11\x17W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`$\x80\x82\x01R\x7FEpoch is not proven to the relay`D\x82\x01R\x7F yet\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[_\x82\x81R`\x04` R`@\x90 Ta\x03\xA9\x90d\x01\0\0\0\0\x90\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B\x89V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x11\xBAW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[a\x11\xC3_a\x1B\xB0V[V[_Tt\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16a\x12.W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1A`$\x82\x01R\x7FRelay is not ready for use\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Tu\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x04`\xFF\x16\x15a\x12\xAFW3_\x90\x81R`\x05` R`@\x90 T`\xFF\x16a\x12\xAFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01R\x7FSubmitter unauthorized\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[_Ta\x12\xCD\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02a\"\xAFV[a\x12\xD8\x90`Pa\"\xAFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81Q\x14a\x131W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01R\x7FInvalid header length\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[`\x01Th\x01\0\0\0\0\0\0\0\0\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16_\x90\x81R`\x04` R`@\x81 \x80T\x90\x91d\x01\0\0\0\0\x90\x91\x04{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x80[_T`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a\x14:W_\x80a\x13\xB6\x87a\x13\xB0\x85`Pa#\x1FV[\x86a\x1A\x87V[\x91P\x91P\x84\x81\x14a\x14/W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FInvalid target in pre-retarget h`D\x82\x01R\x7Feaders\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[P\x91P`\x01\x01a\x13\x85V[P_\x80Ta\x14{\x90a\x14_\x90`\x01\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a#6V[a\x14j\x90`Pa\"\xAFV[\x86\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B^V[c\xFF\xFF\xFF\xFF\x16\x90PB\x81\x10a\x14\xD2W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FEpoch cannot end in the future\0\0`D\x82\x01R`d\x01a\x04lV[\x83T_\x90a\x14\xE8\x90\x85\x90c\xFF\xFF\xFF\xFF\x16\x84a\x1C$V[_\x80T\x91\x92P\x90\x81\x90a\x15\"\x90a\x15\x11\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`Pa\"\xAFV[\x89\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16a\x1B^V[_Tc\xFF\xFF\xFF\xFF\x91\x90\x91\x16\x91P`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16[_Ta\x15_\x90`\x01`\xB0\x1B\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x02a\"\xAFV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x81\x10\x15a\x16eW_\x80a\x15\x81\x8Ba\x07\x90\x85`Pa#\x1FV[\x91P\x91P\x84_\x03a\x15\xE5W\x80\x94P\x80\x86\x16\x81\x14a\x15\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FInvalid target in new epoch\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x16ZV[\x84\x81\x14a\x16ZW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7FUnexpected target change after r`D\x82\x01R\x7Fetarget\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[P\x95P`\x01\x01a\x15AV[P`\x01`\x08\x90T\x90a\x01\0\n\x90\x04g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16`\x01a\x16\x89\x91\x90a\"\xD9V[`\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x92\x83\x16h\x01\0\0\0\0\0\0\0\0\x90\x81\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x92\x16\x91\x90\x91\x17\x91\x82\x90U`@\x80Q\x80\x82\x01\x82Rc\xFF\xFF\xFF\xFF\x80\x87\x16\x82R{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x80\x89\x16` \x80\x85\x01\x91\x82R\x95\x90\x96\x04\x90\x96\x16_\x90\x81R`\x04\x90\x94R\x91\x83 \x90Q\x93Q\x90\x94\x16d\x01\0\0\0\0\x02\x92\x16\x91\x90\x91\x17\x90\x91U`\x02T\x90a\x17D\x84a\x1B\x89V[`\x03\x83\x90U`\x02\x81\x90U`@\x80Q\x84\x81R` \x81\x01\x83\x90R\x91\x92P\x7F\xA2\x82\xEEy\x8B\x13/\x9D\xC1\x1E\x06\xCDM\x8Ev~V+\xE8p\x96\x02\xCA\x14\xFE\xA7\xAB3\x92\xAC\xBD\xAB\x91\x01`@Q\x80\x91\x03\x90\xA1PPPPPPPPPPV[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x17\xFCW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16_\x81\x81R`\x05` \x90\x81R`@\x91\x82\x90 \x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x16`\x01\x17\x90U\x90Q\x91\x82R\x7F\xD56I\xB4\x92\xF78\xBBY\xD6\x82P\x99\xB5\x95Ps\xEF\xDA\x0B\xF9\xE3\xA7\xAD \xDA\"\xE1\x10\x12.)\x91\x01a\n\xE5V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x18\xE0W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[_\x80T\x82\x15\x15u\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x90U`@Q\x7F\xD8\x13\xB2H\xD4\x9C\x8B\xF0\x8B\xE2\xB6\x94q&\xDAgc\xDF1\x0B\xEE\xD7\xBE\xA9wVElW'A\x9A\x90a\n\xE5\x90\x83\x15\x15\x81R` \x01\x90V[_Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x163\x14a\x19\xBFW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7FOwnable: caller is not the owner`D\x82\x01R`d\x01a\x04lV[s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16a\x1AHW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FOwnable: new owner is the zero a`D\x82\x01R\x7Fddress\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x04lV[a\x1AQ\x81a\x1B\xB0V[PV[_a\x03\xA9a\x1Aa\x83a\x1C\xB6V[`\xD8\x81\x90\x1Cc\xFF\0\xFF\0\x16b\xFF\0\xFF`\xE8\x92\x90\x92\x1C\x91\x90\x91\x16\x17`\x10\x81\x81\x1B\x91\x90\x1C\x17\x90V[_\x80\x82\x15a\x1A\xE6Wa\x1A\x9A\x85\x85\x85a\x1C\xC2V[a\x1A\xE6W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\r`$\x82\x01R\x7FInvalid chain\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x1A\xF0\x85\x85a\x1C\xEBV[\x90Pa\x1A\xFE\x85\x85`Pa\x1D\x88V[\x91Pa\x1B\n\x82\x82a\x1D\xADV[a\x1BVW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0C`$\x82\x01R\x7FInvalid work\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x04lV[\x93P\x93\x91PPV[_a\x1Bwa\x1Aaa\x1Bp\x84`Da#VV[\x85\x90a\x1F\x03V[\x93\x92PPPV[_a\x03\xA9\x82_a\x1C\xEBV[_a\x03\xA9{\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83a\x1F\x11V[_\x80Ts\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x81\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x16\x81\x17\x84U`@Q\x91\x90\x92\x16\x92\x83\x91\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x91\x90\xA3PPV[_\x80a\x1C0\x83\x85a\x1F\x1CV[\x90Pa\x1C@b\x12u\0`\x04a\x1F\x11V[\x81\x10\x15a\x1CXWa\x1CUb\x12u\0`\x04a\x1F\x11V[\x90P[a\x1Cfb\x12u\0`\x04a\x1FwV[\x81\x11\x15a\x1C~Wa\x1C{b\x12u\0`\x04a\x1FwV[\x90P[_a\x1C\x96\x82a\x1C\x90\x88b\x01\0\0a\x1F\x11V[\x90a\x1FwV[\x90Pa\x1C\xACb\x01\0\0a\x1C\x90\x83b\x12u\0a\x1F\x11V[\x96\x95PPPPPPV[_a\x03\xA9\x82`Da\x1F\x03V[_\x80a\x1C\xCE\x85\x85a\x1F\xEAV[\x90P\x82\x81\x14a\x1C\xE0W_\x91PPa\x1BwV[P`\x01\x94\x93PPPPV[_\x80a\x1C\xFBa\x1Bp\x84`Ha#VV[`\xE8\x1C\x90P_\x84a\x1D\r\x85`Ka#VV[\x81Q\x81\x10a\x1D\x1DWa\x1D\x1Da#iV[\x01` \x01Q`\xF8\x1C\x90P_a\x1DO\x83_`\x10\x82b\xFF\xFF\xFF\x16\x90\x1C\x82a\xFF\0\x16`\x10\x84b\xFF\xFF\xFF\x16\x90\x1B\x17\x17\x90P\x91\x90PV[b\xFF\xFF\xFF\x16\x90P_a\x1Db`\x03\x84a#\x96V[`\xFF\x16\x90Pa\x1Ds\x81a\x01\0a$\x8AV[a\x1D}\x90\x83a#\x1FV[\x97\x96PPPPPPPV[_` _\x83\x85` \x01\x87\x01`\x02Z\xFAP` _` _`\x02Z\xFAPP_Q\x93\x92PPPV[_\x82a\x1D\xBAWP_a\x03\xA9V[\x81a\x1E\xFB\x84_\x81\x90P`\x08\x81~\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\x16\x90\x1B`\x08\x82\x90\x1C~\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\0\xFF\x16\x17\x90P`\x10\x81}\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\x16\x90\x1B`\x10\x82\x90\x1C}\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\x16\x17\x90P` \x81{\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\x16\x90\x1B` \x82\x90\x1C{\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\xFF\xFF\x16\x17\x90P`@\x81w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x90\x1B`@\x82\x90\x1Cw\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x17\x90P`\x80\x81\x90\x1B`\x80\x82\x90\x1C\x17\x90P\x91\x90PV[\x10\x93\x92PPPV[_a\x1Bw\x83\x83\x01` \x01Q\x90V[_a\x1Bw\x82\x84a\"\x9CV[_\x82\x82\x11\x15a\x1FmW`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FUnderflow during subtraction.\0\0\0`D\x82\x01R`d\x01a\x04lV[a\x1Bw\x82\x84a#\x0CV[_\x82_\x03a\x1F\x86WP_a\x03\xA9V[a\x1F\x90\x82\x84a#\x1FV[\x90P\x81a\x1F\x9D\x84\x83a\"\x9CV[\x14a\x03\xA9W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1F`$\x82\x01R\x7FOverflow during multiplication.\0`D\x82\x01R`d\x01a\x04lV[_a\x1Bwa\x1F\xF9\x83`\x04a#VV[\x84\x01` \x01Q\x90V[_` \x82\x84\x03\x12\x15a \x12W__\xFD[P5\x91\x90PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a VW__\xFD[\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a lW__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a |W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a \x96Wa \x96a \x19V[`@Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`?\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x85\x01\x16\x01\x16\x81\x01\x81\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17\x15a!\x02Wa!\x02a \x19V[`@R\x81\x81R\x82\x82\x01` \x01\x86\x10\x15a!\x19W__\xFD[\x81` \x84\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a!MW__\xFD[\x91\x90PV[_` \x82\x84\x03\x12\x15a!bW__\xFD[a\x1Bw\x82a!6V[_` \x82\x84\x03\x12\x15a!{W__\xFD[\x815s\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x1BwW__\xFD[____``\x85\x87\x03\x12\x15a!\xB1W__\xFD[\x845g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xC7W__\xFD[\x85\x01`\x1F\x81\x01\x87\x13a!\xD7W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a!\xEDW__\xFD[\x87` \x82\x84\x01\x01\x11\x15a!\xFEW__\xFD[` \x91\x82\x01\x95P\x93P\x85\x015\x91Pa\"\x18`@\x86\x01a!6V[\x90P\x92\x95\x91\x94P\x92PV[_` \x82\x84\x03\x12\x15a\"3W__\xFD[\x815\x80\x15\x15\x81\x14a\x1BwW__\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[_\x82a\"\xAAWa\"\xAAa\"BV[P\x04\x90V[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x02\x90\x81\x16\x90\x81\x81\x14a\"\xD2Wa\"\xD2a\"oV[P\x92\x91PPV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[_\x82a#\x07Wa#\x07a\"BV[P\x06\x90V[\x81\x81\x03\x81\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x03\xA9Wa\x03\xA9a\"oV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x80\x82\x01\x80\x82\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[`\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x03\xA9Wa\x03\xA9a\"oV[`\x01\x81[`\x01\x84\x11\x15a\x1BVW\x80\x85\x04\x81\x11\x15a#\xCEWa#\xCEa\"oV[`\x01\x84\x16\x15a#\xDCW\x90\x81\x02\x90[`\x01\x93\x90\x93\x1C\x92\x80\x02a#\xB3V[_\x82a#\xF8WP`\x01a\x03\xA9V[\x81a$\x04WP_a\x03\xA9V[\x81`\x01\x81\x14a$\x1AW`\x02\x81\x14a$$Wa$@V[`\x01\x91PPa\x03\xA9V[`\xFF\x84\x11\x15a$5Wa$5a\"oV[PP`\x01\x82\x1Ba\x03\xA9V[P` \x83\x10a\x013\x83\x10\x16`N\x84\x10`\x0B\x84\x10\x16\x17\x15a$cWP\x81\x81\na\x03\xA9V[a$o_\x19\x84\x84a#\xAFV[\x80_\x19\x04\x82\x11\x15a$\x82Wa$\x82a\"oV[\x02\x93\x92PPPV[_a\x1Bw\x83\x83a#\xEAV\xFE\xA2dipfsX\"\x12 \xFB\x86\x19\xA5\xA2|v\xC8\x1C \x90\xAC\x02\xDB\xED\x11%\xC3\x16l(\x82z\x82B\x18\x1A\r\x91\xD5\xAA\xCDdsolcC\0\x08\x1B\x003",
    );
    /**Event with signature `AuthorizationRequirementChanged(bool)` and selector `0xd813b248d49c8bf08be2b6947126da6763df310beed7bea97756456c5727419a`.
```solidity
event AuthorizationRequirementChanged(bool newStatus);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AuthorizationRequirementChanged {
        #[allow(missing_docs)]
        pub newStatus: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AuthorizationRequirementChanged {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "AuthorizationRequirementChanged(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                216u8,
                19u8,
                178u8,
                72u8,
                212u8,
                156u8,
                139u8,
                240u8,
                139u8,
                226u8,
                182u8,
                148u8,
                113u8,
                38u8,
                218u8,
                103u8,
                99u8,
                223u8,
                49u8,
                11u8,
                238u8,
                215u8,
                190u8,
                169u8,
                119u8,
                86u8,
                69u8,
                108u8,
                87u8,
                39u8,
                65u8,
                154u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newStatus: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.newStatus,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AuthorizationRequirementChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AuthorizationRequirementChanged>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AuthorizationRequirementChanged,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Genesis(uint256)` and selector `0x2381d16925551c2fb1a5edfcf4fce2f6d085e1f85f4b88340c09c9d191f9d4e9`.
```solidity
event Genesis(uint256 blockHeight);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Genesis {
        #[allow(missing_docs)]
        pub blockHeight: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Genesis {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Genesis(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                35u8,
                129u8,
                209u8,
                105u8,
                37u8,
                85u8,
                28u8,
                47u8,
                177u8,
                165u8,
                237u8,
                252u8,
                244u8,
                252u8,
                226u8,
                246u8,
                208u8,
                133u8,
                225u8,
                248u8,
                95u8,
                75u8,
                136u8,
                52u8,
                12u8,
                9u8,
                201u8,
                209u8,
                145u8,
                249u8,
                212u8,
                233u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { blockHeight: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHeight),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Genesis {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Genesis> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Genesis) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.previousOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ProofLengthChanged(uint256)` and selector `0x3e9f904d8cf11753c79b67c8259c582056d4a7d8af120f81257a59eeb8824b96`.
```solidity
event ProofLengthChanged(uint256 newLength);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProofLengthChanged {
        #[allow(missing_docs)]
        pub newLength: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProofLengthChanged {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProofLengthChanged(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                62u8,
                159u8,
                144u8,
                77u8,
                140u8,
                241u8,
                23u8,
                83u8,
                199u8,
                155u8,
                103u8,
                200u8,
                37u8,
                156u8,
                88u8,
                32u8,
                86u8,
                212u8,
                167u8,
                216u8,
                175u8,
                18u8,
                15u8,
                129u8,
                37u8,
                122u8,
                89u8,
                238u8,
                184u8,
                130u8,
                75u8,
                150u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newLength: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newLength),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProofLengthChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProofLengthChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProofLengthChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Retarget(uint256,uint256)` and selector `0xa282ee798b132f9dc11e06cd4d8e767e562be8709602ca14fea7ab3392acbdab`.
```solidity
event Retarget(uint256 oldDifficulty, uint256 newDifficulty);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Retarget {
        #[allow(missing_docs)]
        pub oldDifficulty: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newDifficulty: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Retarget {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Retarget(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                162u8,
                130u8,
                238u8,
                121u8,
                139u8,
                19u8,
                47u8,
                157u8,
                193u8,
                30u8,
                6u8,
                205u8,
                77u8,
                142u8,
                118u8,
                126u8,
                86u8,
                43u8,
                232u8,
                112u8,
                150u8,
                2u8,
                202u8,
                20u8,
                254u8,
                167u8,
                171u8,
                51u8,
                146u8,
                172u8,
                189u8,
                171u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldDifficulty: data.0,
                    newDifficulty: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.oldDifficulty),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newDifficulty),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Retarget {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Retarget> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Retarget) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SubmitterAuthorized(address)` and selector `0xd53649b492f738bb59d6825099b5955073efda0bf9e3a7ad20da22e110122e29`.
```solidity
event SubmitterAuthorized(address submitter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubmitterAuthorized {
        #[allow(missing_docs)]
        pub submitter: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubmitterAuthorized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SubmitterAuthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                213u8,
                54u8,
                73u8,
                180u8,
                146u8,
                247u8,
                56u8,
                187u8,
                89u8,
                214u8,
                130u8,
                80u8,
                153u8,
                181u8,
                149u8,
                80u8,
                115u8,
                239u8,
                218u8,
                11u8,
                249u8,
                227u8,
                167u8,
                173u8,
                32u8,
                218u8,
                34u8,
                225u8,
                16u8,
                18u8,
                46u8,
                41u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { submitter: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.submitter,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubmitterAuthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubmitterAuthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SubmitterAuthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SubmitterDeauthorized(address)` and selector `0x7498b96beeabea5ad3139f1a2861a03e480034254e36b10aae2e6e42ad7b4b68`.
```solidity
event SubmitterDeauthorized(address submitter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubmitterDeauthorized {
        #[allow(missing_docs)]
        pub submitter: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubmitterDeauthorized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SubmitterDeauthorized(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                116u8,
                152u8,
                185u8,
                107u8,
                238u8,
                171u8,
                234u8,
                90u8,
                211u8,
                19u8,
                159u8,
                26u8,
                40u8,
                97u8,
                160u8,
                62u8,
                72u8,
                0u8,
                52u8,
                37u8,
                78u8,
                54u8,
                177u8,
                10u8,
                174u8,
                46u8,
                110u8,
                66u8,
                173u8,
                123u8,
                75u8,
                104u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { submitter: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.submitter,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubmitterDeauthorized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubmitterDeauthorized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SubmitterDeauthorized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `authorizationRequired()` and selector `0x95410d2b`.
```solidity
function authorizationRequired() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizationRequiredCall {}
    ///Container type for the return parameters of the [`authorizationRequired()`](authorizationRequiredCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizationRequiredReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizationRequiredCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizationRequiredCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizationRequiredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizationRequiredReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: authorizationRequiredReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for authorizationRequiredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizationRequiredCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizationRequiredReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorizationRequired()";
            const SELECTOR: [u8; 4] = [149u8, 65u8, 13u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `authorize(address)` and selector `0xb6a5d7de`.
```solidity
function authorize(address submitter) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizeCall {
        pub submitter: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`authorize(address)`](authorizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct authorizeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: authorizeCall) -> Self {
                    (value.submitter,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for authorizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { submitter: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<authorizeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: authorizeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for authorizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for authorizeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = authorizeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "authorize(address)";
            const SELECTOR: [u8; 4] = [182u8, 165u8, 215u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.submitter,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `currentEpoch()` and selector `0x76671808`.
```solidity
function currentEpoch() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochCall {}
    ///Container type for the return parameters of the [`currentEpoch()`](currentEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentEpochReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = currentEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentEpoch()";
            const SELECTOR: [u8; 4] = [118u8, 103u8, 24u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deauthorize(address)` and selector `0x27c97fa5`.
```solidity
function deauthorize(address submitter) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deauthorizeCall {
        pub submitter: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`deauthorize(address)`](deauthorizeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deauthorizeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deauthorizeCall> for UnderlyingRustTuple<'_> {
                fn from(value: deauthorizeCall) -> Self {
                    (value.submitter,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deauthorizeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { submitter: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deauthorizeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: deauthorizeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deauthorizeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deauthorizeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deauthorizeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deauthorize(address)";
            const SELECTOR: [u8; 4] = [39u8, 201u8, 127u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.submitter,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `genesis(bytes,uint256,uint64)` and selector `0x4ca49f51`.
```solidity
function genesis(bytes memory genesisHeader, uint256 genesisHeight, uint64 genesisProofLength) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisCall {
        pub genesisHeader: alloy::sol_types::private::Bytes,
        pub genesisHeight: alloy::sol_types::private::primitives::aliases::U256,
        pub genesisProofLength: u64,
    }
    ///Container type for the return parameters of the [`genesis(bytes,uint256,uint64)`](genesisCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisCall> for UnderlyingRustTuple<'_> {
                fn from(value: genesisCall) -> Self {
                    (value.genesisHeader, value.genesisHeight, value.genesisProofLength)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for genesisCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        genesisHeader: tuple.0,
                        genesisHeight: tuple.1,
                        genesisProofLength: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisReturn> for UnderlyingRustTuple<'_> {
                fn from(value: genesisReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for genesisReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for genesisCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = genesisReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "genesis(bytes,uint256,uint64)";
            const SELECTOR: [u8; 4] = [76u8, 164u8, 159u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.genesisHeader,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.genesisHeight),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.genesisProofLength),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `genesisEpoch()` and selector `0xb70e6be6`.
```solidity
function genesisEpoch() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisEpochCall {}
    ///Container type for the return parameters of the [`genesisEpoch()`](genesisEpochCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct genesisEpochReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisEpochCall> for UnderlyingRustTuple<'_> {
                fn from(value: genesisEpochCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for genesisEpochCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<genesisEpochReturn> for UnderlyingRustTuple<'_> {
                fn from(value: genesisEpochReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for genesisEpochReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for genesisEpochCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = genesisEpochReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "genesisEpoch()";
            const SELECTOR: [u8; 4] = [183u8, 14u8, 107u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlockDifficulty(uint256)` and selector `0x06a27422`.
```solidity
function getBlockDifficulty(uint256 blockNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockDifficultyCall {
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getBlockDifficulty(uint256)`](getBlockDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockDifficultyReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockDifficultyCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockDifficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockDifficultyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlockDifficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockDifficulty(uint256)";
            const SELECTOR: [u8; 4] = [6u8, 162u8, 116u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentAndPrevEpochDifficulty()` and selector `0x3a1b77b0`.
```solidity
function getCurrentAndPrevEpochDifficulty() external view returns (uint256 current, uint256 previous);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentAndPrevEpochDifficultyCall {}
    ///Container type for the return parameters of the [`getCurrentAndPrevEpochDifficulty()`](getCurrentAndPrevEpochDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentAndPrevEpochDifficultyReturn {
        pub current: alloy::sol_types::private::primitives::aliases::U256,
        pub previous: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentAndPrevEpochDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentAndPrevEpochDifficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentAndPrevEpochDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentAndPrevEpochDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentAndPrevEpochDifficultyReturn) -> Self {
                    (value.current, value.previous)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentAndPrevEpochDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        current: tuple.0,
                        previous: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentAndPrevEpochDifficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentAndPrevEpochDifficultyReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentAndPrevEpochDifficulty()";
            const SELECTOR: [u8; 4] = [58u8, 27u8, 119u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getCurrentEpochDifficulty()` and selector `0x113764be`.
```solidity
function getCurrentEpochDifficulty() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochDifficultyCall {}
    ///Container type for the return parameters of the [`getCurrentEpochDifficulty()`](getCurrentEpochDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCurrentEpochDifficultyReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochDifficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentEpochDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentEpochDifficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCurrentEpochDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentEpochDifficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentEpochDifficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentEpochDifficulty()";
            const SELECTOR: [u8; 4] = [17u8, 55u8, 100u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getEpochDifficulty(uint256)` and selector `0x620414e6`.
```solidity
function getEpochDifficulty(uint256 epochNumber) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochDifficultyCall {
        pub epochNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`getEpochDifficulty(uint256)`](getEpochDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getEpochDifficultyReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochDifficultyCall) -> Self {
                    (value.epochNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { epochNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getEpochDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getEpochDifficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getEpochDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getEpochDifficultyCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getEpochDifficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getEpochDifficulty(uint256)";
            const SELECTOR: [u8; 4] = [98u8, 4u8, 20u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.epochNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getPrevEpochDifficulty()` and selector `0x2b97be24`.
```solidity
function getPrevEpochDifficulty() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevEpochDifficultyCall {}
    ///Container type for the return parameters of the [`getPrevEpochDifficulty()`](getPrevEpochDifficultyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPrevEpochDifficultyReturn {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevEpochDifficultyCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevEpochDifficultyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevEpochDifficultyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPrevEpochDifficultyReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPrevEpochDifficultyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPrevEpochDifficultyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPrevEpochDifficultyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getPrevEpochDifficultyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPrevEpochDifficulty()";
            const SELECTOR: [u8; 4] = [43u8, 151u8, 190u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRelayRange()` and selector `0x10b76ed8`.
```solidity
function getRelayRange() external view returns (uint256 relayGenesis, uint256 currentEpochEnd);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRelayRangeCall {}
    ///Container type for the return parameters of the [`getRelayRange()`](getRelayRangeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRelayRangeReturn {
        pub relayGenesis: alloy::sol_types::private::primitives::aliases::U256,
        pub currentEpochEnd: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRelayRangeCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRelayRangeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRelayRangeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRelayRangeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRelayRangeReturn) -> Self {
                    (value.relayGenesis, value.currentEpochEnd)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRelayRangeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        relayGenesis: tuple.0,
                        currentEpochEnd: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRelayRangeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRelayRangeReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRelayRange()";
            const SELECTOR: [u8; 4] = [16u8, 183u8, 110u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isAuthorized(address)` and selector `0xfe9fbb80`.
```solidity
function isAuthorized(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuthorizedCall {
        pub _0: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isAuthorized(address)`](isAuthorizedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isAuthorizedReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuthorizedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isAuthorizedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAuthorizedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isAuthorizedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isAuthorizedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isAuthorizedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isAuthorizedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isAuthorizedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isAuthorized(address)";
            const SELECTOR: [u8; 4] = [254u8, 159u8, 187u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall {}
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `proofLength()` and selector `0xf5619fda`.
```solidity
function proofLength() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proofLengthCall {}
    ///Container type for the return parameters of the [`proofLength()`](proofLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proofLengthReturn {
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proofLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: proofLengthCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proofLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proofLengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proofLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proofLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proofLengthCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proofLengthReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proofLength()";
            const SELECTOR: [u8; 4] = [245u8, 97u8, 159u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `ready()` and selector `0x6defbf80`.
```solidity
function ready() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readyCall {}
    ///Container type for the return parameters of the [`ready()`](readyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct readyReturn {
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readyCall> for UnderlyingRustTuple<'_> {
                fn from(value: readyCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<readyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: readyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for readyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for readyCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = readyReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ready()";
            const SELECTOR: [u8; 4] = [109u8, 239u8, 191u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `retarget(bytes)` and selector `0x7ca5b1dd`.
```solidity
function retarget(bytes memory headers) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct retargetCall {
        pub headers: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`retarget(bytes)`](retargetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct retargetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<retargetCall> for UnderlyingRustTuple<'_> {
                fn from(value: retargetCall) -> Self {
                    (value.headers,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for retargetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { headers: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<retargetReturn> for UnderlyingRustTuple<'_> {
                fn from(value: retargetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for retargetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for retargetCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = retargetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "retarget(bytes)";
            const SELECTOR: [u8; 4] = [124u8, 165u8, 177u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.headers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setAuthorizationStatus(bool)` and selector `0xeb8695ef`.
```solidity
function setAuthorizationStatus(bool status) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAuthorizationStatusCall {
        pub status: bool,
    }
    ///Container type for the return parameters of the [`setAuthorizationStatus(bool)`](setAuthorizationStatusCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setAuthorizationStatusReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAuthorizationStatusCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAuthorizationStatusCall) -> Self {
                    (value.status,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAuthorizationStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { status: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setAuthorizationStatusReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setAuthorizationStatusReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setAuthorizationStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setAuthorizationStatusCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setAuthorizationStatusReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setAuthorizationStatus(bool)";
            const SELECTOR: [u8; 4] = [235u8, 134u8, 149u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.status,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setProofLength(uint64)` and selector `0x19c9aa32`.
```solidity
function setProofLength(uint64 newLength) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProofLengthCall {
        pub newLength: u64,
    }
    ///Container type for the return parameters of the [`setProofLength(uint64)`](setProofLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProofLengthReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProofLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: setProofLengthCall) -> Self {
                    (value.newLength,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setProofLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newLength: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProofLengthReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProofLengthReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProofLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProofLengthCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProofLengthReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProofLength(uint64)";
            const SELECTOR: [u8; 4] = [25u8, 201u8, 170u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.newLength),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `validateChain(bytes)` and selector `0x189179a3`.
```solidity
function validateChain(bytes memory headers) external view returns (uint256 startingHeaderTimestamp, uint256 headerCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateChainCall {
        pub headers: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`validateChain(bytes)`](validateChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct validateChainReturn {
        pub startingHeaderTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        pub headerCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateChainCall> for UnderlyingRustTuple<'_> {
                fn from(value: validateChainCall) -> Self {
                    (value.headers,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for validateChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { headers: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<validateChainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: validateChainReturn) -> Self {
                    (value.startingHeaderTimestamp, value.headerCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for validateChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingHeaderTimestamp: tuple.0,
                        headerCount: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for validateChainCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = validateChainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "validateChain(bytes)";
            const SELECTOR: [u8; 4] = [24u8, 145u8, 121u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.headers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`LightRelay`](self) function calls.
    pub enum LightRelayCalls {
        authorizationRequired(authorizationRequiredCall),
        authorize(authorizeCall),
        currentEpoch(currentEpochCall),
        deauthorize(deauthorizeCall),
        genesis(genesisCall),
        genesisEpoch(genesisEpochCall),
        getBlockDifficulty(getBlockDifficultyCall),
        getCurrentAndPrevEpochDifficulty(getCurrentAndPrevEpochDifficultyCall),
        getCurrentEpochDifficulty(getCurrentEpochDifficultyCall),
        getEpochDifficulty(getEpochDifficultyCall),
        getPrevEpochDifficulty(getPrevEpochDifficultyCall),
        getRelayRange(getRelayRangeCall),
        isAuthorized(isAuthorizedCall),
        owner(ownerCall),
        proofLength(proofLengthCall),
        ready(readyCall),
        renounceOwnership(renounceOwnershipCall),
        retarget(retargetCall),
        setAuthorizationStatus(setAuthorizationStatusCall),
        setProofLength(setProofLengthCall),
        transferOwnership(transferOwnershipCall),
        validateChain(validateChainCall),
    }
    #[automatically_derived]
    impl LightRelayCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [6u8, 162u8, 116u8, 34u8],
            [16u8, 183u8, 110u8, 216u8],
            [17u8, 55u8, 100u8, 190u8],
            [24u8, 145u8, 121u8, 163u8],
            [25u8, 201u8, 170u8, 50u8],
            [39u8, 201u8, 127u8, 165u8],
            [43u8, 151u8, 190u8, 36u8],
            [58u8, 27u8, 119u8, 176u8],
            [76u8, 164u8, 159u8, 81u8],
            [98u8, 4u8, 20u8, 230u8],
            [109u8, 239u8, 191u8, 128u8],
            [113u8, 80u8, 24u8, 166u8],
            [118u8, 103u8, 24u8, 8u8],
            [124u8, 165u8, 177u8, 221u8],
            [141u8, 165u8, 203u8, 91u8],
            [149u8, 65u8, 13u8, 43u8],
            [182u8, 165u8, 215u8, 222u8],
            [183u8, 14u8, 107u8, 230u8],
            [235u8, 134u8, 149u8, 239u8],
            [242u8, 253u8, 227u8, 139u8],
            [245u8, 97u8, 159u8, 218u8],
            [254u8, 159u8, 187u8, 128u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for LightRelayCalls {
        const NAME: &'static str = "LightRelayCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 22usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::authorizationRequired(_) => {
                    <authorizationRequiredCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::authorize(_) => {
                    <authorizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentEpoch(_) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deauthorize(_) => {
                    <deauthorizeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::genesis(_) => <genesisCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::genesisEpoch(_) => {
                    <genesisEpochCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockDifficulty(_) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentAndPrevEpochDifficulty(_) => {
                    <getCurrentAndPrevEpochDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getCurrentEpochDifficulty(_) => {
                    <getCurrentEpochDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getEpochDifficulty(_) => {
                    <getEpochDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPrevEpochDifficulty(_) => {
                    <getPrevEpochDifficultyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRelayRange(_) => {
                    <getRelayRangeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isAuthorized(_) => {
                    <isAuthorizedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proofLength(_) => {
                    <proofLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ready(_) => <readyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::retarget(_) => <retargetCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setAuthorizationStatus(_) => {
                    <setAuthorizationStatusCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProofLength(_) => {
                    <setProofLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::validateChain(_) => {
                    <validateChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<LightRelayCalls>] = &[
                {
                    fn getBlockDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getBlockDifficulty)
                    }
                    getBlockDifficulty
                },
                {
                    fn getRelayRange(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getRelayRangeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getRelayRange)
                    }
                    getRelayRange
                },
                {
                    fn getCurrentEpochDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getCurrentEpochDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getCurrentEpochDifficulty)
                    }
                    getCurrentEpochDifficulty
                },
                {
                    fn validateChain(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <validateChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::validateChain)
                    }
                    validateChain
                },
                {
                    fn setProofLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <setProofLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::setProofLength)
                    }
                    setProofLength
                },
                {
                    fn deauthorize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <deauthorizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::deauthorize)
                    }
                    deauthorize
                },
                {
                    fn getPrevEpochDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getPrevEpochDifficulty)
                    }
                    getPrevEpochDifficulty
                },
                {
                    fn getCurrentAndPrevEpochDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getCurrentAndPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getCurrentAndPrevEpochDifficulty)
                    }
                    getCurrentAndPrevEpochDifficulty
                },
                {
                    fn genesis(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <genesisCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::genesis)
                    }
                    genesis
                },
                {
                    fn getEpochDifficulty(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <getEpochDifficultyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::getEpochDifficulty)
                    }
                    getEpochDifficulty
                },
                {
                    fn ready(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <readyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::ready)
                    }
                    ready
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn currentEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <currentEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::currentEpoch)
                    }
                    currentEpoch
                },
                {
                    fn retarget(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <retargetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::retarget)
                    }
                    retarget
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::owner)
                    }
                    owner
                },
                {
                    fn authorizationRequired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <authorizationRequiredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::authorizationRequired)
                    }
                    authorizationRequired
                },
                {
                    fn authorize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <authorizeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::authorize)
                    }
                    authorize
                },
                {
                    fn genesisEpoch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <genesisEpochCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::genesisEpoch)
                    }
                    genesisEpoch
                },
                {
                    fn setAuthorizationStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <setAuthorizationStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::setAuthorizationStatus)
                    }
                    setAuthorizationStatus
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn proofLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <proofLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::proofLength)
                    }
                    proofLength
                },
                {
                    fn isAuthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<LightRelayCalls> {
                        <isAuthorizedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(LightRelayCalls::isAuthorized)
                    }
                    isAuthorized
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::authorizationRequired(inner) => {
                    <authorizationRequiredCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::authorize(inner) => {
                    <authorizeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deauthorize(inner) => {
                    <deauthorizeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::genesis(inner) => {
                    <genesisCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::genesisEpoch(inner) => {
                    <genesisEpochCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockDifficulty(inner) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentAndPrevEpochDifficulty(inner) => {
                    <getCurrentAndPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getCurrentEpochDifficulty(inner) => {
                    <getCurrentEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getEpochDifficulty(inner) => {
                    <getEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPrevEpochDifficulty(inner) => {
                    <getPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRelayRange(inner) => {
                    <getRelayRangeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isAuthorized(inner) => {
                    <isAuthorizedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proofLength(inner) => {
                    <proofLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ready(inner) => {
                    <readyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::retarget(inner) => {
                    <retargetCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setAuthorizationStatus(inner) => {
                    <setAuthorizationStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProofLength(inner) => {
                    <setProofLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::validateChain(inner) => {
                    <validateChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::authorizationRequired(inner) => {
                    <authorizationRequiredCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::authorize(inner) => {
                    <authorizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentEpoch(inner) => {
                    <currentEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deauthorize(inner) => {
                    <deauthorizeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::genesis(inner) => {
                    <genesisCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::genesisEpoch(inner) => {
                    <genesisEpochCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockDifficulty(inner) => {
                    <getBlockDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentAndPrevEpochDifficulty(inner) => {
                    <getCurrentAndPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getCurrentEpochDifficulty(inner) => {
                    <getCurrentEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getEpochDifficulty(inner) => {
                    <getEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPrevEpochDifficulty(inner) => {
                    <getPrevEpochDifficultyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRelayRange(inner) => {
                    <getRelayRangeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isAuthorized(inner) => {
                    <isAuthorizedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proofLength(inner) => {
                    <proofLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ready(inner) => {
                    <readyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::retarget(inner) => {
                    <retargetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setAuthorizationStatus(inner) => {
                    <setAuthorizationStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProofLength(inner) => {
                    <setProofLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::validateChain(inner) => {
                    <validateChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`LightRelay`](self) events.
    pub enum LightRelayEvents {
        AuthorizationRequirementChanged(AuthorizationRequirementChanged),
        Genesis(Genesis),
        OwnershipTransferred(OwnershipTransferred),
        ProofLengthChanged(ProofLengthChanged),
        Retarget(Retarget),
        SubmitterAuthorized(SubmitterAuthorized),
        SubmitterDeauthorized(SubmitterDeauthorized),
    }
    #[automatically_derived]
    impl LightRelayEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                35u8,
                129u8,
                209u8,
                105u8,
                37u8,
                85u8,
                28u8,
                47u8,
                177u8,
                165u8,
                237u8,
                252u8,
                244u8,
                252u8,
                226u8,
                246u8,
                208u8,
                133u8,
                225u8,
                248u8,
                95u8,
                75u8,
                136u8,
                52u8,
                12u8,
                9u8,
                201u8,
                209u8,
                145u8,
                249u8,
                212u8,
                233u8,
            ],
            [
                62u8,
                159u8,
                144u8,
                77u8,
                140u8,
                241u8,
                23u8,
                83u8,
                199u8,
                155u8,
                103u8,
                200u8,
                37u8,
                156u8,
                88u8,
                32u8,
                86u8,
                212u8,
                167u8,
                216u8,
                175u8,
                18u8,
                15u8,
                129u8,
                37u8,
                122u8,
                89u8,
                238u8,
                184u8,
                130u8,
                75u8,
                150u8,
            ],
            [
                116u8,
                152u8,
                185u8,
                107u8,
                238u8,
                171u8,
                234u8,
                90u8,
                211u8,
                19u8,
                159u8,
                26u8,
                40u8,
                97u8,
                160u8,
                62u8,
                72u8,
                0u8,
                52u8,
                37u8,
                78u8,
                54u8,
                177u8,
                10u8,
                174u8,
                46u8,
                110u8,
                66u8,
                173u8,
                123u8,
                75u8,
                104u8,
            ],
            [
                139u8,
                224u8,
                7u8,
                156u8,
                83u8,
                22u8,
                89u8,
                20u8,
                19u8,
                68u8,
                205u8,
                31u8,
                208u8,
                164u8,
                242u8,
                132u8,
                25u8,
                73u8,
                127u8,
                151u8,
                34u8,
                163u8,
                218u8,
                175u8,
                227u8,
                180u8,
                24u8,
                111u8,
                107u8,
                100u8,
                87u8,
                224u8,
            ],
            [
                162u8,
                130u8,
                238u8,
                121u8,
                139u8,
                19u8,
                47u8,
                157u8,
                193u8,
                30u8,
                6u8,
                205u8,
                77u8,
                142u8,
                118u8,
                126u8,
                86u8,
                43u8,
                232u8,
                112u8,
                150u8,
                2u8,
                202u8,
                20u8,
                254u8,
                167u8,
                171u8,
                51u8,
                146u8,
                172u8,
                189u8,
                171u8,
            ],
            [
                213u8,
                54u8,
                73u8,
                180u8,
                146u8,
                247u8,
                56u8,
                187u8,
                89u8,
                214u8,
                130u8,
                80u8,
                153u8,
                181u8,
                149u8,
                80u8,
                115u8,
                239u8,
                218u8,
                11u8,
                249u8,
                227u8,
                167u8,
                173u8,
                32u8,
                218u8,
                34u8,
                225u8,
                16u8,
                18u8,
                46u8,
                41u8,
            ],
            [
                216u8,
                19u8,
                178u8,
                72u8,
                212u8,
                156u8,
                139u8,
                240u8,
                139u8,
                226u8,
                182u8,
                148u8,
                113u8,
                38u8,
                218u8,
                103u8,
                99u8,
                223u8,
                49u8,
                11u8,
                238u8,
                215u8,
                190u8,
                169u8,
                119u8,
                86u8,
                69u8,
                108u8,
                87u8,
                39u8,
                65u8,
                154u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for LightRelayEvents {
        const NAME: &'static str = "LightRelayEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AuthorizationRequirementChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AuthorizationRequirementChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AuthorizationRequirementChanged)
                }
                Some(<Genesis as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Genesis as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Genesis)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <ProofLengthChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProofLengthChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ProofLengthChanged)
                }
                Some(<Retarget as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Retarget as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Retarget)
                }
                Some(
                    <SubmitterAuthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubmitterAuthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SubmitterAuthorized)
                }
                Some(
                    <SubmitterDeauthorized as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubmitterDeauthorized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SubmitterDeauthorized)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for LightRelayEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AuthorizationRequirementChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Genesis(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProofLengthChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Retarget(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubmitterAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubmitterDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AuthorizationRequirementChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Genesis(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProofLengthChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Retarget(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubmitterAuthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubmitterDeauthorized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`LightRelay`](self) contract instance.

See the [wrapper's documentation](`LightRelayInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> LightRelayInstance<T, P, N> {
        LightRelayInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<LightRelayInstance<T, P, N>>,
    > {
        LightRelayInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        LightRelayInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`LightRelay`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`LightRelay`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct LightRelayInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for LightRelayInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("LightRelayInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > LightRelayInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`LightRelay`](self) contract instance.

See the [wrapper's documentation](`LightRelayInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<LightRelayInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> LightRelayInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> LightRelayInstance<T, P, N> {
            LightRelayInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > LightRelayInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`authorizationRequired`] function.
        pub fn authorizationRequired(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizationRequiredCall, N> {
            self.call_builder(&authorizationRequiredCall {})
        }
        ///Creates a new call builder for the [`authorize`] function.
        pub fn authorize(
            &self,
            submitter: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, authorizeCall, N> {
            self.call_builder(&authorizeCall { submitter })
        }
        ///Creates a new call builder for the [`currentEpoch`] function.
        pub fn currentEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, currentEpochCall, N> {
            self.call_builder(&currentEpochCall {})
        }
        ///Creates a new call builder for the [`deauthorize`] function.
        pub fn deauthorize(
            &self,
            submitter: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, deauthorizeCall, N> {
            self.call_builder(&deauthorizeCall { submitter })
        }
        ///Creates a new call builder for the [`genesis`] function.
        pub fn genesis(
            &self,
            genesisHeader: alloy::sol_types::private::Bytes,
            genesisHeight: alloy::sol_types::private::primitives::aliases::U256,
            genesisProofLength: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, genesisCall, N> {
            self.call_builder(
                &genesisCall {
                    genesisHeader,
                    genesisHeight,
                    genesisProofLength,
                },
            )
        }
        ///Creates a new call builder for the [`genesisEpoch`] function.
        pub fn genesisEpoch(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, genesisEpochCall, N> {
            self.call_builder(&genesisEpochCall {})
        }
        ///Creates a new call builder for the [`getBlockDifficulty`] function.
        pub fn getBlockDifficulty(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlockDifficultyCall, N> {
            self.call_builder(
                &getBlockDifficultyCall {
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getCurrentAndPrevEpochDifficulty`] function.
        pub fn getCurrentAndPrevEpochDifficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getCurrentAndPrevEpochDifficultyCall,
            N,
        > {
            self.call_builder(
                &getCurrentAndPrevEpochDifficultyCall {
                },
            )
        }
        ///Creates a new call builder for the [`getCurrentEpochDifficulty`] function.
        pub fn getCurrentEpochDifficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentEpochDifficultyCall, N> {
            self.call_builder(&getCurrentEpochDifficultyCall {})
        }
        ///Creates a new call builder for the [`getEpochDifficulty`] function.
        pub fn getEpochDifficulty(
            &self,
            epochNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getEpochDifficultyCall, N> {
            self.call_builder(
                &getEpochDifficultyCall {
                    epochNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getPrevEpochDifficulty`] function.
        pub fn getPrevEpochDifficulty(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getPrevEpochDifficultyCall, N> {
            self.call_builder(&getPrevEpochDifficultyCall {})
        }
        ///Creates a new call builder for the [`getRelayRange`] function.
        pub fn getRelayRange(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRelayRangeCall, N> {
            self.call_builder(&getRelayRangeCall {})
        }
        ///Creates a new call builder for the [`isAuthorized`] function.
        pub fn isAuthorized(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isAuthorizedCall, N> {
            self.call_builder(&isAuthorizedCall { _0 })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        ///Creates a new call builder for the [`proofLength`] function.
        pub fn proofLength(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proofLengthCall, N> {
            self.call_builder(&proofLengthCall {})
        }
        ///Creates a new call builder for the [`ready`] function.
        pub fn ready(&self) -> alloy_contract::SolCallBuilder<T, &P, readyCall, N> {
            self.call_builder(&readyCall {})
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        ///Creates a new call builder for the [`retarget`] function.
        pub fn retarget(
            &self,
            headers: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, retargetCall, N> {
            self.call_builder(&retargetCall { headers })
        }
        ///Creates a new call builder for the [`setAuthorizationStatus`] function.
        pub fn setAuthorizationStatus(
            &self,
            status: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setAuthorizationStatusCall, N> {
            self.call_builder(
                &setAuthorizationStatusCall {
                    status,
                },
            )
        }
        ///Creates a new call builder for the [`setProofLength`] function.
        pub fn setProofLength(
            &self,
            newLength: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, setProofLengthCall, N> {
            self.call_builder(&setProofLengthCall { newLength })
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`validateChain`] function.
        pub fn validateChain(
            &self,
            headers: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, validateChainCall, N> {
            self.call_builder(&validateChainCall { headers })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > LightRelayInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AuthorizationRequirementChanged`] event.
        pub fn AuthorizationRequirementChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AuthorizationRequirementChanged, N> {
            self.event_filter::<AuthorizationRequirementChanged>()
        }
        ///Creates a new event filter for the [`Genesis`] event.
        pub fn Genesis_filter(&self) -> alloy_contract::Event<T, &P, Genesis, N> {
            self.event_filter::<Genesis>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ProofLengthChanged`] event.
        pub fn ProofLengthChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ProofLengthChanged, N> {
            self.event_filter::<ProofLengthChanged>()
        }
        ///Creates a new event filter for the [`Retarget`] event.
        pub fn Retarget_filter(&self) -> alloy_contract::Event<T, &P, Retarget, N> {
            self.event_filter::<Retarget>()
        }
        ///Creates a new event filter for the [`SubmitterAuthorized`] event.
        pub fn SubmitterAuthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SubmitterAuthorized, N> {
            self.event_filter::<SubmitterAuthorized>()
        }
        ///Creates a new event filter for the [`SubmitterDeauthorized`] event.
        pub fn SubmitterDeauthorized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SubmitterDeauthorized, N> {
            self.event_filter::<SubmitterDeauthorized>()
        }
    }
}
