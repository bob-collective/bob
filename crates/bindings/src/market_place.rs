/**

Generated by the following Solidity interface...
```solidity
interface MarketPlace {
    struct Order {
        uint256 offeringAmount;
        address offeringToken;
        uint256 askingAmount;
        address askingToken;
        address requesterAddress;
    }

    event acceptOrder(uint256 indexed orderId, address indexed who, uint256 buyAmount, uint256 saleAmount);
    event placeOrder(uint256 indexed orderId, address indexed requesterAddress, uint256 offeringAmount, address offeringToken, uint256 askingAmount, address askingToken);
    event withdrawOrder(uint256 indexed orderId);

    constructor(address erc2771Forwarder);

    function acceptErcErcOrder(uint256 id, uint256 saleAmount) external;
    function ercErcOrders(uint256) external view returns (uint256 offeringAmount, address offeringToken, uint256 askingAmount, address askingToken, address requesterAddress);
    function getOpenOrders() external view returns (Order[] memory, uint256[] memory);
    function getTrustedForwarder() external view returns (address forwarder);
    function isTrustedForwarder(address forwarder) external view returns (bool);
    function nextOrderId() external view returns (uint256);
    function placeErcErcOrder(address sellingToken, uint256 saleAmount, address buyingToken, uint256 buyAmount) external;
    function withdrawErcErcOrder(uint256 id) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "erc2771Forwarder",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "acceptErcErcOrder",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "saleAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "ercErcOrders",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "offeringAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "offeringToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "askingAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "askingToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "requesterAddress",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOpenOrders",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct MarketPlace.Order[]",
        "components": [
          {
            "name": "offeringAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "offeringToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "askingAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "askingToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "requesterAddress",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTrustedForwarder",
    "inputs": [],
    "outputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isTrustedForwarder",
    "inputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextOrderId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "placeErcErcOrder",
    "inputs": [
      {
        "name": "sellingToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "saleAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "buyingToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "buyAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawErcErcOrder",
    "inputs": [
      {
        "name": "id",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "acceptOrder",
    "inputs": [
      {
        "name": "orderId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "who",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "buyAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "saleAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "placeOrder",
    "inputs": [
      {
        "name": "orderId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "requesterAddress",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "offeringAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "offeringToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "askingAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "askingToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "withdrawOrder",
    "inputs": [
      {
        "name": "orderId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MarketPlace {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b5060405161103d38038061103d833981016040819052602b91604a565b5f80546001600160a01b0319166001600160a01b038316179055506075565b5f602082840312156059575f5ffd5b81516001600160a01b0381168114606e575f5ffd5b9392505050565b610fbb806100825f395ff3fe608060405234801561000f575f5ffd5b5060043610610085575f3560e01c80635c5968bb116100585780635c5968bb146100fe578063ce1b815f1461017a578063dbe5bab514610194578063f8181170146101aa575f5ffd5b806304bc1e7b1461008957806322ec54a01461009e5780632a58b330146100b1578063572b6c05146100cd575b5f5ffd5b61009c610097366004610c41565b6101bd565b005b61009c6100ac366004610c73565b6102e7565b6100ba60025481565b6040519081526020015b60405180910390f35b6100ee6100db366004610cb4565b5f546001600160a01b0391821691161490565b60405190151581526020016100c4565b61014861010c366004610c41565b600160208190525f9182526040909120805491810154600282015460038301546004909301546001600160a01b03928316939192918216911685565b604080519586526001600160a01b0394851660208701528501929092528216606084015216608082015260a0016100c4565b5f546040516001600160a01b0390911681526020016100c4565b61019c610472565b6040516100c4929190610d07565b61009c6101b8366004610da9565b61063e565b5f81815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082015261021e6107e8565b6001600160a01b031681608001516001600160a01b03161461023e575f5ffd5b6102606102496107e8565b825160208401516001600160a01b03169190610838565b5f82815260016020819052604080832083815591820180547fffffffffffffffffffffffff00000000000000000000000000000000000000009081169091556002830184905560038301805482169055600490920180549092169091555183917ffb791b0b90b74a62a7d039583362b4be244b07227262232394e923c16488ed3191a25050565b6001600160a01b0384166102f9575f5ffd5b6001600160a01b03821661030b575f5ffd5b6103286103166107e8565b6001600160a01b038616903086610904565b600280545f918261033883610df6565b9190505590505f6040518060a00160405280868152602001876001600160a01b03168152602001848152602001856001600160a01b0316815260200161037c6107e8565b6001600160a01b039081169091525f8481526001602081815260409283902085518082559186015192810180548487167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915584870151600283018190556060880151600384018054828a169085161790556080890151600490940180549490981693909216831790965593519596509487947fc4046a305c59edb2472e638a28cedb16563c8aa0a4f8faffcaef1c43a26f886c9461046294929384526001600160a01b039283166020850152604084019190915216606082015260800190565b60405180910390a3505050505050565b6060805f805b6002548110156104ab575f81815260016020526040902054156104a3578161049f81610df6565b9250505b600101610478565b505f8167ffffffffffffffff8111156104c6576104c6610e0e565b60405190808252806020026020018201604052801561051d57816020015b6040805160a0810182525f808252602080830182905292820181905260608201819052608082015282525f199092019101816104e45790505b5090505f8267ffffffffffffffff81111561053a5761053a610e0e565b604051908082528060200260200182016040528015610563578160200160208202803683370190505b5090505f805b600254811015610632575f818152600160205260409020541561062a575f81815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082015284518590849081106105f3576105f3610e3b565b60200260200101819052508083838151811061061157610611610e3b565b60209081029190910101528161062681610df6565b9250505b600101610569565b50919590945092505050565b5f82815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082018190526106a1575f5ffd5b80604001518211156106b1575f5ffd5b604081015181515f91906106c59085610e68565b6106cf9190610e85565b90505f83116106e0576106e0610ebd565b5f81116106ef576106ef610ebd565b815181111561070057610700610ebd565b5f848152600160205260408120805483929061071d908490610eea565b90915550505f8481526001602052604081206002018054859290610742908490610eea565b9091555061076e90506107536107e8565b608084015160608501516001600160a01b0316919086610904565b61078e6107796107e8565b60208401516001600160a01b03169083610838565b6107966107e8565b6001600160a01b0316847f011fcf6fc53fc79971c9e93f9adced6c1f2723177b4b92be86102b0558fbb03883866040516107da929190918252602082015260400190565b60405180910390a350505050565b5f6014361080159061080357505f546001600160a01b031633145b1561083357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c90565b503390565b6040516001600160a01b0383166024820152604481018290526108ff9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261095b565b505050565b6040516001600160a01b03808516602483015283166044820152606481018290526109559085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161087d565b50505050565b5f6109af826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610a5e9092919063ffffffff16565b8051909150156108ff57808060200190518101906109cd9190610efd565b6108ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b6060610a6c84845f85610a76565b90505b9392505050565b606082471015610b08576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610a55565b6001600160a01b0385163b610b79576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610a55565b5f5f866001600160a01b03168587604051610b949190610f1c565b5f6040518083038185875af1925050503d805f8114610bce576040519150601f19603f3d011682016040523d82523d5f602084013e610bd3565b606091505b5091509150610be3828286610bee565b979650505050505050565b60608315610bfd575081610a6f565b825115610c0d5782518084602001fd5b816040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a559190610f32565b5f60208284031215610c51575f5ffd5b5035919050565b80356001600160a01b0381168114610c6e575f5ffd5b919050565b5f5f5f5f60808587031215610c86575f5ffd5b610c8f85610c58565b935060208501359250610ca460408601610c58565b9396929550929360600135925050565b5f60208284031215610cc4575f5ffd5b610a6f82610c58565b5f8151808452602084019350602083015f5b82811015610cfd578151865260209586019590910190600101610cdf565b5093949350505050565b604080825283519082018190525f9060208501906060840190835b81811015610d8b578351805184526001600160a01b036020820151166020850152604081015160408501526001600160a01b0360608201511660608501526001600160a01b0360808201511660808501525060a083019250602084019350600181019050610d22565b50508381036020850152610d9f8186610ccd565b9695505050505050565b5f5f60408385031215610dba575f5ffd5b50508035926020909101359150565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f5f198203610e0757610e07610dc9565b5060010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8082028115828204841417610e7f57610e7f610dc9565b92915050565b5f82610eb8577f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b500490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b81810381811115610e7f57610e7f610dc9565b5f60208284031215610f0d575f5ffd5b81518015158114610a6f575f5ffd5b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fea264697066735822122059a404b07ea614342ac40e25df3a8e0424c2d4525fbe7b9df8b942b6186a310864736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[P`@Qa\x10=8\x03\x80a\x10=\x839\x81\x01`@\x81\x90R`+\x91`JV[_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90UP`uV[_` \x82\x84\x03\x12\x15`YW__\xFD[\x81Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14`nW__\xFD[\x93\x92PPPV[a\x0F\xBB\x80a\0\x82_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\\Yh\xBB\x11a\0XW\x80c\\Yh\xBB\x14a\0\xFEW\x80c\xCE\x1B\x81_\x14a\x01zW\x80c\xDB\xE5\xBA\xB5\x14a\x01\x94W\x80c\xF8\x18\x11p\x14a\x01\xAAW__\xFD[\x80c\x04\xBC\x1E{\x14a\0\x89W\x80c\"\xECT\xA0\x14a\0\x9EW\x80c*X\xB30\x14a\0\xB1W\x80cW+l\x05\x14a\0\xCDW[__\xFD[a\0\x9Ca\0\x976`\x04a\x0CAV[a\x01\xBDV[\0[a\0\x9Ca\0\xAC6`\x04a\x0CsV[a\x02\xE7V[a\0\xBA`\x02T\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xEEa\0\xDB6`\x04a\x0C\xB4V[_T`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x14\x90V[`@Q\x90\x15\x15\x81R` \x01a\0\xC4V[a\x01Ha\x01\x0C6`\x04a\x0CAV[`\x01` \x81\x90R_\x91\x82R`@\x90\x91 \x80T\x91\x81\x01T`\x02\x82\x01T`\x03\x83\x01T`\x04\x90\x93\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x93\x91\x92\x91\x82\x16\x91\x16\x85V[`@\x80Q\x95\x86R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16` \x87\x01R\x85\x01\x92\x90\x92R\x82\x16``\x84\x01R\x16`\x80\x82\x01R`\xA0\x01a\0\xC4V[_T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xC4V[a\x01\x9Ca\x04rV[`@Qa\0\xC4\x92\x91\x90a\r\x07V[a\0\x9Ca\x01\xB86`\x04a\r\xA9V[a\x06>V[_\x81\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01Ra\x02\x1Ea\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x80\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x14a\x02>W__\xFD[a\x02`a\x02Ia\x07\xE8V[\x82Q` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x90a\x088V[_\x82\x81R`\x01` \x81\x90R`@\x80\x83 \x83\x81U\x91\x82\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x81\x16\x90\x91U`\x02\x83\x01\x84\x90U`\x03\x83\x01\x80T\x82\x16\x90U`\x04\x90\x92\x01\x80T\x90\x92\x16\x90\x91UQ\x83\x91\x7F\xFBy\x1B\x0B\x90\xB7Jb\xA7\xD09X3b\xB4\xBE$K\x07\"rb##\x94\xE9#\xC1d\x88\xED1\x91\xA2PPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x02\xF9W__\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x03\x0BW__\xFD[a\x03(a\x03\x16a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x86\x16\x900\x86a\t\x04V[`\x02\x80T_\x91\x82a\x038\x83a\r\xF6V[\x91\x90PU\x90P_`@Q\x80`\xA0\x01`@R\x80\x86\x81R` \x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x84\x81R` \x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01a\x03|a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x91R_\x84\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x85Q\x80\x82U\x91\x86\x01Q\x92\x81\x01\x80T\x84\x87\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x17\x90\x91U\x84\x87\x01Q`\x02\x83\x01\x81\x90U``\x88\x01Q`\x03\x84\x01\x80T\x82\x8A\x16\x90\x85\x16\x17\x90U`\x80\x89\x01Q`\x04\x90\x94\x01\x80T\x94\x90\x98\x16\x93\x90\x92\x16\x83\x17\x90\x96U\x93Q\x95\x96P\x94\x87\x94\x7F\xC4\x04j0\\Y\xED\xB2G.c\x8A(\xCE\xDB\x16V<\x8A\xA0\xA4\xF8\xFA\xFF\xCA\xEF\x1CC\xA2o\x88l\x94a\x04b\x94\x92\x93\x84R`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x85\x01R`@\x84\x01\x91\x90\x91R\x16``\x82\x01R`\x80\x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[``\x80_\x80[`\x02T\x81\x10\x15a\x04\xABW_\x81\x81R`\x01` R`@\x90 T\x15a\x04\xA3W\x81a\x04\x9F\x81a\r\xF6V[\x92PP[`\x01\x01a\x04xV[P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\xC6Wa\x04\xC6a\x0E\x0EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x05\x1DW\x81` \x01[`@\x80Q`\xA0\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01\x81\x90R``\x82\x01\x81\x90R`\x80\x82\x01R\x82R_\x19\x90\x92\x01\x91\x01\x81a\x04\xE4W\x90P[P\x90P_\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x05:Wa\x05:a\x0E\x0EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x05cW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x80[`\x02T\x81\x10\x15a\x062W_\x81\x81R`\x01` R`@\x90 T\x15a\x06*W_\x81\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01R\x84Q\x85\x90\x84\x90\x81\x10a\x05\xF3Wa\x05\xF3a\x0E;V[` \x02` \x01\x01\x81\x90RP\x80\x83\x83\x81Q\x81\x10a\x06\x11Wa\x06\x11a\x0E;V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x81a\x06&\x81a\r\xF6V[\x92PP[`\x01\x01a\x05iV[P\x91\x95\x90\x94P\x92PPPV[_\x82\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01\x81\x90Ra\x06\xA1W__\xFD[\x80`@\x01Q\x82\x11\x15a\x06\xB1W__\xFD[`@\x81\x01Q\x81Q_\x91\x90a\x06\xC5\x90\x85a\x0EhV[a\x06\xCF\x91\x90a\x0E\x85V[\x90P_\x83\x11a\x06\xE0Wa\x06\xE0a\x0E\xBDV[_\x81\x11a\x06\xEFWa\x06\xEFa\x0E\xBDV[\x81Q\x81\x11\x15a\x07\0Wa\x07\0a\x0E\xBDV[_\x84\x81R`\x01` R`@\x81 \x80T\x83\x92\x90a\x07\x1D\x90\x84\x90a\x0E\xEAV[\x90\x91UPP_\x84\x81R`\x01` R`@\x81 `\x02\x01\x80T\x85\x92\x90a\x07B\x90\x84\x90a\x0E\xEAV[\x90\x91UPa\x07n\x90Pa\x07Sa\x07\xE8V[`\x80\x84\x01Q``\x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x90\x86a\t\x04V[a\x07\x8Ea\x07ya\x07\xE8V[` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x83a\x088V[a\x07\x96a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x16\x84\x7F\x01\x1F\xCFo\xC5?\xC7\x99q\xC9\xE9?\x9A\xDC\xEDl\x1F'#\x17{K\x92\xBE\x86\x10+\x05X\xFB\xB08\x83\x86`@Qa\x07\xDA\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPV[_`\x146\x10\x80\x15\x90a\x08\x03WP_T`\x01`\x01`\xA0\x1B\x03\x163\x14[\x15a\x083WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xEC6\x015``\x1C\x90V[P3\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\x08\xFF\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra\t[V[PPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\tU\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a\x08}V[PPPPV[_a\t\xAF\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\n^\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x08\xFFW\x80\x80` \x01\x90Q\x81\x01\x90a\t\xCD\x91\x90a\x0E\xFDV[a\x08\xFFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[``a\nl\x84\x84_\x85a\nvV[\x90P[\x93\x92PPPV[``\x82G\x10\x15a\x0B\x08W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\nUV[`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x0ByW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\nUV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x0B\x94\x91\x90a\x0F\x1CV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x0B\xCEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x0B\xD3V[``\x91P[P\x91P\x91Pa\x0B\xE3\x82\x82\x86a\x0B\xEEV[\x97\x96PPPPPPPV[``\x83\x15a\x0B\xFDWP\x81a\noV[\x82Q\x15a\x0C\rW\x82Q\x80\x84` \x01\xFD[\x81`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\nU\x91\x90a\x0F2V[_` \x82\x84\x03\x12\x15a\x0CQW__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0CnW__\xFD[\x91\x90PV[____`\x80\x85\x87\x03\x12\x15a\x0C\x86W__\xFD[a\x0C\x8F\x85a\x0CXV[\x93P` \x85\x015\x92Pa\x0C\xA4`@\x86\x01a\x0CXV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[_` \x82\x84\x03\x12\x15a\x0C\xC4W__\xFD[a\no\x82a\x0CXV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x0C\xFDW\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x0C\xDFV[P\x93\x94\x93PPPPV[`@\x80\x82R\x83Q\x90\x82\x01\x81\x90R_\x90` \x85\x01\x90``\x84\x01\x90\x83[\x81\x81\x10\x15a\r\x8BW\x83Q\x80Q\x84R`\x01`\x01`\xA0\x1B\x03` \x82\x01Q\x16` \x85\x01R`@\x81\x01Q`@\x85\x01R`\x01`\x01`\xA0\x1B\x03``\x82\x01Q\x16``\x85\x01R`\x01`\x01`\xA0\x1B\x03`\x80\x82\x01Q\x16`\x80\x85\x01RP`\xA0\x83\x01\x92P` \x84\x01\x93P`\x01\x81\x01\x90Pa\r\"V[PP\x83\x81\x03` \x85\x01Ra\r\x9F\x81\x86a\x0C\xCDV[\x96\x95PPPPPPV[__`@\x83\x85\x03\x12\x15a\r\xBAW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[__\x19\x82\x03a\x0E\x07Wa\x0E\x07a\r\xC9V[P`\x01\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x0E\x7FWa\x0E\x7Fa\r\xC9V[\x92\x91PPV[_\x82a\x0E\xB8W\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[P\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x0E\x7FWa\x0E\x7Fa\r\xC9V[_` \x82\x84\x03\x12\x15a\x0F\rW__\xFD[\x81Q\x80\x15\x15\x81\x14a\noW__\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 Y\xA4\x04\xB0~\xA6\x144*\xC4\x0E%\xDF:\x8E\x04$\xC2\xD4R_\xBE{\x9D\xF8\xB9B\xB6\x18j1\x08dsolcC\0\x08\x1C\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b5060043610610085575f3560e01c80635c5968bb116100585780635c5968bb146100fe578063ce1b815f1461017a578063dbe5bab514610194578063f8181170146101aa575f5ffd5b806304bc1e7b1461008957806322ec54a01461009e5780632a58b330146100b1578063572b6c05146100cd575b5f5ffd5b61009c610097366004610c41565b6101bd565b005b61009c6100ac366004610c73565b6102e7565b6100ba60025481565b6040519081526020015b60405180910390f35b6100ee6100db366004610cb4565b5f546001600160a01b0391821691161490565b60405190151581526020016100c4565b61014861010c366004610c41565b600160208190525f9182526040909120805491810154600282015460038301546004909301546001600160a01b03928316939192918216911685565b604080519586526001600160a01b0394851660208701528501929092528216606084015216608082015260a0016100c4565b5f546040516001600160a01b0390911681526020016100c4565b61019c610472565b6040516100c4929190610d07565b61009c6101b8366004610da9565b61063e565b5f81815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082015261021e6107e8565b6001600160a01b031681608001516001600160a01b03161461023e575f5ffd5b6102606102496107e8565b825160208401516001600160a01b03169190610838565b5f82815260016020819052604080832083815591820180547fffffffffffffffffffffffff00000000000000000000000000000000000000009081169091556002830184905560038301805482169055600490920180549092169091555183917ffb791b0b90b74a62a7d039583362b4be244b07227262232394e923c16488ed3191a25050565b6001600160a01b0384166102f9575f5ffd5b6001600160a01b03821661030b575f5ffd5b6103286103166107e8565b6001600160a01b038616903086610904565b600280545f918261033883610df6565b9190505590505f6040518060a00160405280868152602001876001600160a01b03168152602001848152602001856001600160a01b0316815260200161037c6107e8565b6001600160a01b039081169091525f8481526001602081815260409283902085518082559186015192810180548487167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915584870151600283018190556060880151600384018054828a169085161790556080890151600490940180549490981693909216831790965593519596509487947fc4046a305c59edb2472e638a28cedb16563c8aa0a4f8faffcaef1c43a26f886c9461046294929384526001600160a01b039283166020850152604084019190915216606082015260800190565b60405180910390a3505050505050565b6060805f805b6002548110156104ab575f81815260016020526040902054156104a3578161049f81610df6565b9250505b600101610478565b505f8167ffffffffffffffff8111156104c6576104c6610e0e565b60405190808252806020026020018201604052801561051d57816020015b6040805160a0810182525f808252602080830182905292820181905260608201819052608082015282525f199092019101816104e45790505b5090505f8267ffffffffffffffff81111561053a5761053a610e0e565b604051908082528060200260200182016040528015610563578160200160208202803683370190505b5090505f805b600254811015610632575f818152600160205260409020541561062a575f81815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082015284518590849081106105f3576105f3610e3b565b60200260200101819052508083838151811061061157610611610e3b565b60209081029190910101528161062681610df6565b9250505b600101610569565b50919590945092505050565b5f82815260016020818152604092839020835160a08101855281548152928101546001600160a01b0390811692840192909252600281015493830193909352600383015481166060830152600490920154909116608082018190526106a1575f5ffd5b80604001518211156106b1575f5ffd5b604081015181515f91906106c59085610e68565b6106cf9190610e85565b90505f83116106e0576106e0610ebd565b5f81116106ef576106ef610ebd565b815181111561070057610700610ebd565b5f848152600160205260408120805483929061071d908490610eea565b90915550505f8481526001602052604081206002018054859290610742908490610eea565b9091555061076e90506107536107e8565b608084015160608501516001600160a01b0316919086610904565b61078e6107796107e8565b60208401516001600160a01b03169083610838565b6107966107e8565b6001600160a01b0316847f011fcf6fc53fc79971c9e93f9adced6c1f2723177b4b92be86102b0558fbb03883866040516107da929190918252602082015260400190565b60405180910390a350505050565b5f6014361080159061080357505f546001600160a01b031633145b1561083357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c90565b503390565b6040516001600160a01b0383166024820152604481018290526108ff9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261095b565b505050565b6040516001600160a01b03808516602483015283166044820152606481018290526109559085907f23b872dd000000000000000000000000000000000000000000000000000000009060840161087d565b50505050565b5f6109af826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610a5e9092919063ffffffff16565b8051909150156108ff57808060200190518101906109cd9190610efd565b6108ff576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b6060610a6c84845f85610a76565b90505b9392505050565b606082471015610b08576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610a55565b6001600160a01b0385163b610b79576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610a55565b5f5f866001600160a01b03168587604051610b949190610f1c565b5f6040518083038185875af1925050503d805f8114610bce576040519150601f19603f3d011682016040523d82523d5f602084013e610bd3565b606091505b5091509150610be3828286610bee565b979650505050505050565b60608315610bfd575081610a6f565b825115610c0d5782518084602001fd5b816040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a559190610f32565b5f60208284031215610c51575f5ffd5b5035919050565b80356001600160a01b0381168114610c6e575f5ffd5b919050565b5f5f5f5f60808587031215610c86575f5ffd5b610c8f85610c58565b935060208501359250610ca460408601610c58565b9396929550929360600135925050565b5f60208284031215610cc4575f5ffd5b610a6f82610c58565b5f8151808452602084019350602083015f5b82811015610cfd578151865260209586019590910190600101610cdf565b5093949350505050565b604080825283519082018190525f9060208501906060840190835b81811015610d8b578351805184526001600160a01b036020820151166020850152604081015160408501526001600160a01b0360608201511660608501526001600160a01b0360808201511660808501525060a083019250602084019350600181019050610d22565b50508381036020850152610d9f8186610ccd565b9695505050505050565b5f5f60408385031215610dba575f5ffd5b50508035926020909101359150565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f5f198203610e0757610e07610dc9565b5060010190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b8082028115828204841417610e7f57610e7f610dc9565b92915050565b5f82610eb8577f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b500490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52600160045260245ffd5b81810381811115610e7f57610e7f610dc9565b5f60208284031215610f0d575f5ffd5b81518015158114610a6f575f5ffd5b5f82518060208501845e5f920191825250919050565b602081525f82518060208401528060208501604085015e5f6040828501015260407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168401019150509291505056fea264697066735822122059a404b07ea614342ac40e25df3a8e0424c2d4525fbe7b9df8b942b6186a310864736f6c634300081c0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\x85W_5`\xE0\x1C\x80c\\Yh\xBB\x11a\0XW\x80c\\Yh\xBB\x14a\0\xFEW\x80c\xCE\x1B\x81_\x14a\x01zW\x80c\xDB\xE5\xBA\xB5\x14a\x01\x94W\x80c\xF8\x18\x11p\x14a\x01\xAAW__\xFD[\x80c\x04\xBC\x1E{\x14a\0\x89W\x80c\"\xECT\xA0\x14a\0\x9EW\x80c*X\xB30\x14a\0\xB1W\x80cW+l\x05\x14a\0\xCDW[__\xFD[a\0\x9Ca\0\x976`\x04a\x0CAV[a\x01\xBDV[\0[a\0\x9Ca\0\xAC6`\x04a\x0CsV[a\x02\xE7V[a\0\xBA`\x02T\x81V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xEEa\0\xDB6`\x04a\x0C\xB4V[_T`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x14\x90V[`@Q\x90\x15\x15\x81R` \x01a\0\xC4V[a\x01Ha\x01\x0C6`\x04a\x0CAV[`\x01` \x81\x90R_\x91\x82R`@\x90\x91 \x80T\x91\x81\x01T`\x02\x82\x01T`\x03\x83\x01T`\x04\x90\x93\x01T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x93\x91\x92\x91\x82\x16\x91\x16\x85V[`@\x80Q\x95\x86R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16` \x87\x01R\x85\x01\x92\x90\x92R\x82\x16``\x84\x01R\x16`\x80\x82\x01R`\xA0\x01a\0\xC4V[_T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xC4V[a\x01\x9Ca\x04rV[`@Qa\0\xC4\x92\x91\x90a\r\x07V[a\0\x9Ca\x01\xB86`\x04a\r\xA9V[a\x06>V[_\x81\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01Ra\x02\x1Ea\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x16\x81`\x80\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x14a\x02>W__\xFD[a\x02`a\x02Ia\x07\xE8V[\x82Q` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x90a\x088V[_\x82\x81R`\x01` \x81\x90R`@\x80\x83 \x83\x81U\x91\x82\x01\x80T\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x81\x16\x90\x91U`\x02\x83\x01\x84\x90U`\x03\x83\x01\x80T\x82\x16\x90U`\x04\x90\x92\x01\x80T\x90\x92\x16\x90\x91UQ\x83\x91\x7F\xFBy\x1B\x0B\x90\xB7Jb\xA7\xD09X3b\xB4\xBE$K\x07\"rb##\x94\xE9#\xC1d\x88\xED1\x91\xA2PPV[`\x01`\x01`\xA0\x1B\x03\x84\x16a\x02\xF9W__\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16a\x03\x0BW__\xFD[a\x03(a\x03\x16a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x86\x16\x900\x86a\t\x04V[`\x02\x80T_\x91\x82a\x038\x83a\r\xF6V[\x91\x90PU\x90P_`@Q\x80`\xA0\x01`@R\x80\x86\x81R` \x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x84\x81R` \x01\x85`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01a\x03|a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x91R_\x84\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x85Q\x80\x82U\x91\x86\x01Q\x92\x81\x01\x80T\x84\x87\x16\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x82\x16\x17\x90\x91U\x84\x87\x01Q`\x02\x83\x01\x81\x90U``\x88\x01Q`\x03\x84\x01\x80T\x82\x8A\x16\x90\x85\x16\x17\x90U`\x80\x89\x01Q`\x04\x90\x94\x01\x80T\x94\x90\x98\x16\x93\x90\x92\x16\x83\x17\x90\x96U\x93Q\x95\x96P\x94\x87\x94\x7F\xC4\x04j0\\Y\xED\xB2G.c\x8A(\xCE\xDB\x16V<\x8A\xA0\xA4\xF8\xFA\xFF\xCA\xEF\x1CC\xA2o\x88l\x94a\x04b\x94\x92\x93\x84R`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x85\x01R`@\x84\x01\x91\x90\x91R\x16``\x82\x01R`\x80\x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPPPV[``\x80_\x80[`\x02T\x81\x10\x15a\x04\xABW_\x81\x81R`\x01` R`@\x90 T\x15a\x04\xA3W\x81a\x04\x9F\x81a\r\xF6V[\x92PP[`\x01\x01a\x04xV[P_\x81g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x04\xC6Wa\x04\xC6a\x0E\x0EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x05\x1DW\x81` \x01[`@\x80Q`\xA0\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01\x81\x90R``\x82\x01\x81\x90R`\x80\x82\x01R\x82R_\x19\x90\x92\x01\x91\x01\x81a\x04\xE4W\x90P[P\x90P_\x82g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x05:Wa\x05:a\x0E\x0EV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x05cW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_\x80[`\x02T\x81\x10\x15a\x062W_\x81\x81R`\x01` R`@\x90 T\x15a\x06*W_\x81\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01R\x84Q\x85\x90\x84\x90\x81\x10a\x05\xF3Wa\x05\xF3a\x0E;V[` \x02` \x01\x01\x81\x90RP\x80\x83\x83\x81Q\x81\x10a\x06\x11Wa\x06\x11a\x0E;V[` \x90\x81\x02\x91\x90\x91\x01\x01R\x81a\x06&\x81a\r\xF6V[\x92PP[`\x01\x01a\x05iV[P\x91\x95\x90\x94P\x92PPPV[_\x82\x81R`\x01` \x81\x81R`@\x92\x83\x90 \x83Q`\xA0\x81\x01\x85R\x81T\x81R\x92\x81\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x84\x01\x92\x90\x92R`\x02\x81\x01T\x93\x83\x01\x93\x90\x93R`\x03\x83\x01T\x81\x16``\x83\x01R`\x04\x90\x92\x01T\x90\x91\x16`\x80\x82\x01\x81\x90Ra\x06\xA1W__\xFD[\x80`@\x01Q\x82\x11\x15a\x06\xB1W__\xFD[`@\x81\x01Q\x81Q_\x91\x90a\x06\xC5\x90\x85a\x0EhV[a\x06\xCF\x91\x90a\x0E\x85V[\x90P_\x83\x11a\x06\xE0Wa\x06\xE0a\x0E\xBDV[_\x81\x11a\x06\xEFWa\x06\xEFa\x0E\xBDV[\x81Q\x81\x11\x15a\x07\0Wa\x07\0a\x0E\xBDV[_\x84\x81R`\x01` R`@\x81 \x80T\x83\x92\x90a\x07\x1D\x90\x84\x90a\x0E\xEAV[\x90\x91UPP_\x84\x81R`\x01` R`@\x81 `\x02\x01\x80T\x85\x92\x90a\x07B\x90\x84\x90a\x0E\xEAV[\x90\x91UPa\x07n\x90Pa\x07Sa\x07\xE8V[`\x80\x84\x01Q``\x85\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x90\x86a\t\x04V[a\x07\x8Ea\x07ya\x07\xE8V[` \x84\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x83a\x088V[a\x07\x96a\x07\xE8V[`\x01`\x01`\xA0\x1B\x03\x16\x84\x7F\x01\x1F\xCFo\xC5?\xC7\x99q\xC9\xE9?\x9A\xDC\xEDl\x1F'#\x17{K\x92\xBE\x86\x10+\x05X\xFB\xB08\x83\x86`@Qa\x07\xDA\x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPPV[_`\x146\x10\x80\x15\x90a\x08\x03WP_T`\x01`\x01`\xA0\x1B\x03\x163\x14[\x15a\x083WP\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xEC6\x015``\x1C\x90V[P3\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x83\x16`$\x82\x01R`D\x81\x01\x82\x90Ra\x08\xFF\x90\x84\x90\x7F\xA9\x05\x9C\xBB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`d\x01[`@\x80Q\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0\x81\x84\x03\x01\x81R\x91\x90R` \x81\x01\x80Q{\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x16\x7F\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x93\x16\x92\x90\x92\x17\x90\x91Ra\t[V[PPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x80\x85\x16`$\x83\x01R\x83\x16`D\x82\x01R`d\x81\x01\x82\x90Ra\tU\x90\x85\x90\x7F#\xB8r\xDD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90`\x84\x01a\x08}V[PPPPV[_a\t\xAF\x82`@Q\x80`@\x01`@R\x80` \x81R` \x01\x7FSafeERC20: low-level call failed\x81RP\x85`\x01`\x01`\xA0\x1B\x03\x16a\n^\x90\x92\x91\x90c\xFF\xFF\xFF\xFF\x16V[\x80Q\x90\x91P\x15a\x08\xFFW\x80\x80` \x01\x90Q\x81\x01\x90a\t\xCD\x91\x90a\x0E\xFDV[a\x08\xFFW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`*`$\x82\x01R\x7FSafeERC20: ERC20 operation did n`D\x82\x01R\x7Fot succeed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01[`@Q\x80\x91\x03\x90\xFD[``a\nl\x84\x84_\x85a\nvV[\x90P[\x93\x92PPPV[``\x82G\x10\x15a\x0B\x08W`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7FAddress: insufficient balance fo`D\x82\x01R\x7Fr call\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\nUV[`\x01`\x01`\xA0\x1B\x03\x85\x16;a\x0ByW`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAddress: call to non-contract\0\0\0`D\x82\x01R`d\x01a\nUV[__\x86`\x01`\x01`\xA0\x1B\x03\x16\x85\x87`@Qa\x0B\x94\x91\x90a\x0F\x1CV[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x0B\xCEW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x0B\xD3V[``\x91P[P\x91P\x91Pa\x0B\xE3\x82\x82\x86a\x0B\xEEV[\x97\x96PPPPPPPV[``\x83\x15a\x0B\xFDWP\x81a\noV[\x82Q\x15a\x0C\rW\x82Q\x80\x84` \x01\xFD[\x81`@Q\x7F\x08\xC3y\xA0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R`\x04\x01a\nU\x91\x90a\x0F2V[_` \x82\x84\x03\x12\x15a\x0CQW__\xFD[P5\x91\x90PV[\x805`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x0CnW__\xFD[\x91\x90PV[____`\x80\x85\x87\x03\x12\x15a\x0C\x86W__\xFD[a\x0C\x8F\x85a\x0CXV[\x93P` \x85\x015\x92Pa\x0C\xA4`@\x86\x01a\x0CXV[\x93\x96\x92\x95P\x92\x93``\x015\x92PPV[_` \x82\x84\x03\x12\x15a\x0C\xC4W__\xFD[a\no\x82a\x0CXV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x0C\xFDW\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x0C\xDFV[P\x93\x94\x93PPPPV[`@\x80\x82R\x83Q\x90\x82\x01\x81\x90R_\x90` \x85\x01\x90``\x84\x01\x90\x83[\x81\x81\x10\x15a\r\x8BW\x83Q\x80Q\x84R`\x01`\x01`\xA0\x1B\x03` \x82\x01Q\x16` \x85\x01R`@\x81\x01Q`@\x85\x01R`\x01`\x01`\xA0\x1B\x03``\x82\x01Q\x16``\x85\x01R`\x01`\x01`\xA0\x1B\x03`\x80\x82\x01Q\x16`\x80\x85\x01RP`\xA0\x83\x01\x92P` \x84\x01\x93P`\x01\x81\x01\x90Pa\r\"V[PP\x83\x81\x03` \x85\x01Ra\r\x9F\x81\x86a\x0C\xCDV[\x96\x95PPPPPPV[__`@\x83\x85\x03\x12\x15a\r\xBAW__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x11`\x04R`$_\xFD[__\x19\x82\x03a\x0E\x07Wa\x0E\x07a\r\xC9V[P`\x01\x01\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`A`\x04R`$_\xFD[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`2`\x04R`$_\xFD[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x0E\x7FWa\x0E\x7Fa\r\xC9V[\x92\x91PPV[_\x82a\x0E\xB8W\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x12`\x04R`$_\xFD[P\x04\x90V[\x7FNH{q\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_R`\x01`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x0E\x7FWa\x0E\x7Fa\r\xC9V[_` \x82\x84\x03\x12\x15a\x0F\rW__\xFD[\x81Q\x80\x15\x15\x81\x14a\noW__\xFD[_\x82Q\x80` \x85\x01\x84^_\x92\x01\x91\x82RP\x91\x90PV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xE0`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV\xFE\xA2dipfsX\"\x12 Y\xA4\x04\xB0~\xA6\x144*\xC4\x0E%\xDF:\x8E\x04$\xC2\xD4R_\xBE{\x9D\xF8\xB9B\xB6\x18j1\x08dsolcC\0\x08\x1C\x003",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Order { uint256 offeringAmount; address offeringToken; uint256 askingAmount; address askingToken; address requesterAddress; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Order {
        #[allow(missing_docs)]
        pub offeringAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub offeringToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub askingAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub askingToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requesterAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Order> for UnderlyingRustTuple<'_> {
            fn from(value: Order) -> Self {
                (
                    value.offeringAmount,
                    value.offeringToken,
                    value.askingAmount,
                    value.askingToken,
                    value.requesterAddress,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Order {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offeringAmount: tuple.0,
                    offeringToken: tuple.1,
                    askingAmount: tuple.2,
                    askingToken: tuple.3,
                    requesterAddress: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Order {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Order {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offeringAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.offeringToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.askingAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.askingToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.requesterAddress,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Order {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Order {
            const NAME: &'static str = "Order";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Order(uint256 offeringAmount,address offeringToken,uint256 askingAmount,address askingToken,address requesterAddress)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.offeringAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.offeringToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.askingAmount)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.askingToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.requesterAddress,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Order {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.offeringAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.offeringToken,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.askingAmount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.askingToken,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requesterAddress,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.offeringAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.offeringToken,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.askingAmount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.askingToken,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requesterAddress,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `acceptOrder(uint256,address,uint256,uint256)` and selector `0x011fcf6fc53fc79971c9e93f9adced6c1f2723177b4b92be86102b0558fbb038`.
```solidity
event acceptOrder(uint256 indexed orderId, address indexed who, uint256 buyAmount, uint256 saleAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct acceptOrder {
        #[allow(missing_docs)]
        pub orderId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub who: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub buyAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub saleAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for acceptOrder {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "acceptOrder(uint256,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                1u8, 31u8, 207u8, 111u8, 197u8, 63u8, 199u8, 153u8, 113u8, 201u8, 233u8,
                63u8, 154u8, 220u8, 237u8, 108u8, 31u8, 39u8, 35u8, 23u8, 123u8, 75u8,
                146u8, 190u8, 134u8, 16u8, 43u8, 5u8, 88u8, 251u8, 176u8, 56u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    orderId: topics.1,
                    who: topics.2,
                    buyAmount: data.0,
                    saleAmount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.buyAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.saleAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.orderId.clone(), self.who.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.orderId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.who,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for acceptOrder {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&acceptOrder> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &acceptOrder) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `placeOrder(uint256,address,uint256,address,uint256,address)` and selector `0xc4046a305c59edb2472e638a28cedb16563c8aa0a4f8faffcaef1c43a26f886c`.
```solidity
event placeOrder(uint256 indexed orderId, address indexed requesterAddress, uint256 offeringAmount, address offeringToken, uint256 askingAmount, address askingToken);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct placeOrder {
        #[allow(missing_docs)]
        pub orderId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requesterAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub offeringAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub offeringToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub askingAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub askingToken: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for placeOrder {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "placeOrder(uint256,address,uint256,address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                196u8, 4u8, 106u8, 48u8, 92u8, 89u8, 237u8, 178u8, 71u8, 46u8, 99u8,
                138u8, 40u8, 206u8, 219u8, 22u8, 86u8, 60u8, 138u8, 160u8, 164u8, 248u8,
                250u8, 255u8, 202u8, 239u8, 28u8, 67u8, 162u8, 111u8, 136u8, 108u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    orderId: topics.1,
                    requesterAddress: topics.2,
                    offeringAmount: data.0,
                    offeringToken: data.1,
                    askingAmount: data.2,
                    askingToken: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offeringAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.offeringToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.askingAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.askingToken,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.orderId.clone(),
                    self.requesterAddress.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.orderId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requesterAddress,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for placeOrder {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&placeOrder> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &placeOrder) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `withdrawOrder(uint256)` and selector `0xfb791b0b90b74a62a7d039583362b4be244b07227262232394e923c16488ed31`.
```solidity
event withdrawOrder(uint256 indexed orderId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct withdrawOrder {
        #[allow(missing_docs)]
        pub orderId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for withdrawOrder {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "withdrawOrder(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                251u8, 121u8, 27u8, 11u8, 144u8, 183u8, 74u8, 98u8, 167u8, 208u8, 57u8,
                88u8, 51u8, 98u8, 180u8, 190u8, 36u8, 75u8, 7u8, 34u8, 114u8, 98u8, 35u8,
                35u8, 148u8, 233u8, 35u8, 193u8, 100u8, 136u8, 237u8, 49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { orderId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.orderId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.orderId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for withdrawOrder {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&withdrawOrder> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &withdrawOrder) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address erc2771Forwarder);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub erc2771Forwarder: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value.erc2771Forwarder,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { erc2771Forwarder: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.erc2771Forwarder,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `acceptErcErcOrder(uint256,uint256)` and selector `0xf8181170`.
```solidity
function acceptErcErcOrder(uint256 id, uint256 saleAmount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptErcErcOrderCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub saleAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`acceptErcErcOrder(uint256,uint256)`](acceptErcErcOrderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct acceptErcErcOrderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptErcErcOrderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptErcErcOrderCall) -> Self {
                    (value.id, value.saleAmount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptErcErcOrderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        id: tuple.0,
                        saleAmount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<acceptErcErcOrderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: acceptErcErcOrderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for acceptErcErcOrderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl acceptErcErcOrderReturn {
            fn _tokenize(
                &self,
            ) -> <acceptErcErcOrderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for acceptErcErcOrderCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = acceptErcErcOrderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "acceptErcErcOrder(uint256,uint256)";
            const SELECTOR: [u8; 4] = [248u8, 24u8, 17u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.saleAmount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                acceptErcErcOrderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ercErcOrders(uint256)` and selector `0x5c5968bb`.
```solidity
function ercErcOrders(uint256) external view returns (uint256 offeringAmount, address offeringToken, uint256 askingAmount, address askingToken, address requesterAddress);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ercErcOrdersCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ercErcOrders(uint256)`](ercErcOrdersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ercErcOrdersReturn {
        #[allow(missing_docs)]
        pub offeringAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub offeringToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub askingAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub askingToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub requesterAddress: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ercErcOrdersCall> for UnderlyingRustTuple<'_> {
                fn from(value: ercErcOrdersCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ercErcOrdersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ercErcOrdersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ercErcOrdersReturn) -> Self {
                    (
                        value.offeringAmount,
                        value.offeringToken,
                        value.askingAmount,
                        value.askingToken,
                        value.requesterAddress,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ercErcOrdersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        offeringAmount: tuple.0,
                        offeringToken: tuple.1,
                        askingAmount: tuple.2,
                        askingToken: tuple.3,
                        requesterAddress: tuple.4,
                    }
                }
            }
        }
        impl ercErcOrdersReturn {
            fn _tokenize(
                &self,
            ) -> <ercErcOrdersCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offeringAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.offeringToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.askingAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.askingToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.requesterAddress,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ercErcOrdersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ercErcOrdersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ercErcOrders(uint256)";
            const SELECTOR: [u8; 4] = [92u8, 89u8, 104u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                ercErcOrdersReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOpenOrders()` and selector `0xdbe5bab5`.
```solidity
function getOpenOrders() external view returns (Order[] memory, uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOpenOrdersCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOpenOrders()`](getOpenOrdersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOpenOrdersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Order as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOpenOrdersCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOpenOrdersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOpenOrdersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Order>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Order as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOpenOrdersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOpenOrdersReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOpenOrdersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        impl getOpenOrdersReturn {
            fn _tokenize(
                &self,
            ) -> <getOpenOrdersCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Order,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOpenOrdersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOpenOrdersReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<Order>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOpenOrders()";
            const SELECTOR: [u8; 4] = [219u8, 229u8, 186u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getOpenOrdersReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTrustedForwarder()` and selector `0xce1b815f`.
```solidity
function getTrustedForwarder() external view returns (address forwarder);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTrustedForwarderCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTrustedForwarder()`](getTrustedForwarderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTrustedForwarderReturn {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTrustedForwarderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTrustedForwarderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTrustedForwarderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTrustedForwarderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTrustedForwarderReturn) -> Self {
                    (value.forwarder,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTrustedForwarderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { forwarder: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTrustedForwarderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTrustedForwarder()";
            const SELECTOR: [u8; 4] = [206u8, 27u8, 129u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTrustedForwarderReturn = r.into();
                        r.forwarder
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTrustedForwarderReturn = r.into();
                        r.forwarder
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isTrustedForwarder(address)` and selector `0x572b6c05`.
```solidity
function isTrustedForwarder(address forwarder) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTrustedForwarderCall {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isTrustedForwarder(address)`](isTrustedForwarderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isTrustedForwarderReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTrustedForwarderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTrustedForwarderCall) -> Self {
                    (value.forwarder,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTrustedForwarderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { forwarder: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isTrustedForwarderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isTrustedForwarderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isTrustedForwarderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isTrustedForwarderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isTrustedForwarder(address)";
            const SELECTOR: [u8; 4] = [87u8, 43u8, 108u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.forwarder,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isTrustedForwarderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isTrustedForwarderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextOrderId()` and selector `0x2a58b330`.
```solidity
function nextOrderId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextOrderIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextOrderId()`](nextOrderIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextOrderIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextOrderIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextOrderIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextOrderIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextOrderIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nextOrderIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextOrderIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextOrderIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextOrderId()";
            const SELECTOR: [u8; 4] = [42u8, 88u8, 179u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextOrderIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextOrderIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `placeErcErcOrder(address,uint256,address,uint256)` and selector `0x22ec54a0`.
```solidity
function placeErcErcOrder(address sellingToken, uint256 saleAmount, address buyingToken, uint256 buyAmount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct placeErcErcOrderCall {
        #[allow(missing_docs)]
        pub sellingToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub saleAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub buyingToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub buyAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`placeErcErcOrder(address,uint256,address,uint256)`](placeErcErcOrderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct placeErcErcOrderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<placeErcErcOrderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: placeErcErcOrderCall) -> Self {
                    (
                        value.sellingToken,
                        value.saleAmount,
                        value.buyingToken,
                        value.buyAmount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for placeErcErcOrderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sellingToken: tuple.0,
                        saleAmount: tuple.1,
                        buyingToken: tuple.2,
                        buyAmount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<placeErcErcOrderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: placeErcErcOrderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for placeErcErcOrderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl placeErcErcOrderReturn {
            fn _tokenize(
                &self,
            ) -> <placeErcErcOrderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for placeErcErcOrderCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = placeErcErcOrderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "placeErcErcOrder(address,uint256,address,uint256)";
            const SELECTOR: [u8; 4] = [34u8, 236u8, 84u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sellingToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.saleAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.buyingToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.buyAmount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                placeErcErcOrderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawErcErcOrder(uint256)` and selector `0x04bc1e7b`.
```solidity
function withdrawErcErcOrder(uint256 id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawErcErcOrderCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`withdrawErcErcOrder(uint256)`](withdrawErcErcOrderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawErcErcOrderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawErcErcOrderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawErcErcOrderCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawErcErcOrderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawErcErcOrderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawErcErcOrderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawErcErcOrderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawErcErcOrderReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawErcErcOrderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawErcErcOrderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawErcErcOrder(uint256)";
            const SELECTOR: [u8; 4] = [4u8, 188u8, 30u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawErcErcOrderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MarketPlace`](self) function calls.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum MarketPlaceCalls {
        #[allow(missing_docs)]
        acceptErcErcOrder(acceptErcErcOrderCall),
        #[allow(missing_docs)]
        ercErcOrders(ercErcOrdersCall),
        #[allow(missing_docs)]
        getOpenOrders(getOpenOrdersCall),
        #[allow(missing_docs)]
        getTrustedForwarder(getTrustedForwarderCall),
        #[allow(missing_docs)]
        isTrustedForwarder(isTrustedForwarderCall),
        #[allow(missing_docs)]
        nextOrderId(nextOrderIdCall),
        #[allow(missing_docs)]
        placeErcErcOrder(placeErcErcOrderCall),
        #[allow(missing_docs)]
        withdrawErcErcOrder(withdrawErcErcOrderCall),
    }
    #[automatically_derived]
    impl MarketPlaceCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 188u8, 30u8, 123u8],
            [34u8, 236u8, 84u8, 160u8],
            [42u8, 88u8, 179u8, 48u8],
            [87u8, 43u8, 108u8, 5u8],
            [92u8, 89u8, 104u8, 187u8],
            [206u8, 27u8, 129u8, 95u8],
            [219u8, 229u8, 186u8, 181u8],
            [248u8, 24u8, 17u8, 112u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MarketPlaceCalls {
        const NAME: &'static str = "MarketPlaceCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 8usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::acceptErcErcOrder(_) => {
                    <acceptErcErcOrderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ercErcOrders(_) => {
                    <ercErcOrdersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOpenOrders(_) => {
                    <getOpenOrdersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTrustedForwarder(_) => {
                    <getTrustedForwarderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isTrustedForwarder(_) => {
                    <isTrustedForwarderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextOrderId(_) => {
                    <nextOrderIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::placeErcErcOrder(_) => {
                    <placeErcErcOrderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdrawErcErcOrder(_) => {
                    <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MarketPlaceCalls>] = &[
                {
                    fn withdrawErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::withdrawErcErcOrder)
                    }
                    withdrawErcErcOrder
                },
                {
                    fn placeErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <placeErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::placeErcErcOrder)
                    }
                    placeErcErcOrder
                },
                {
                    fn nextOrderId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <nextOrderIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::nextOrderId)
                    }
                    nextOrderId
                },
                {
                    fn isTrustedForwarder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <isTrustedForwarderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::isTrustedForwarder)
                    }
                    isTrustedForwarder
                },
                {
                    fn ercErcOrders(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <ercErcOrdersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::ercErcOrders)
                    }
                    ercErcOrders
                },
                {
                    fn getTrustedForwarder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <getTrustedForwarderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::getTrustedForwarder)
                    }
                    getTrustedForwarder
                },
                {
                    fn getOpenOrders(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <getOpenOrdersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::getOpenOrders)
                    }
                    getOpenOrders
                },
                {
                    fn acceptErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <acceptErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MarketPlaceCalls::acceptErcErcOrder)
                    }
                    acceptErcErcOrder
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MarketPlaceCalls>] = &[
                {
                    fn withdrawErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::withdrawErcErcOrder)
                    }
                    withdrawErcErcOrder
                },
                {
                    fn placeErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <placeErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::placeErcErcOrder)
                    }
                    placeErcErcOrder
                },
                {
                    fn nextOrderId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <nextOrderIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::nextOrderId)
                    }
                    nextOrderId
                },
                {
                    fn isTrustedForwarder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <isTrustedForwarderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::isTrustedForwarder)
                    }
                    isTrustedForwarder
                },
                {
                    fn ercErcOrders(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <ercErcOrdersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::ercErcOrders)
                    }
                    ercErcOrders
                },
                {
                    fn getTrustedForwarder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <getTrustedForwarderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::getTrustedForwarder)
                    }
                    getTrustedForwarder
                },
                {
                    fn getOpenOrders(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <getOpenOrdersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::getOpenOrders)
                    }
                    getOpenOrders
                },
                {
                    fn acceptErcErcOrder(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MarketPlaceCalls> {
                        <acceptErcErcOrderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MarketPlaceCalls::acceptErcErcOrder)
                    }
                    acceptErcErcOrder
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::acceptErcErcOrder(inner) => {
                    <acceptErcErcOrderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ercErcOrders(inner) => {
                    <ercErcOrdersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOpenOrders(inner) => {
                    <getOpenOrdersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTrustedForwarder(inner) => {
                    <getTrustedForwarderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isTrustedForwarder(inner) => {
                    <isTrustedForwarderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextOrderId(inner) => {
                    <nextOrderIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::placeErcErcOrder(inner) => {
                    <placeErcErcOrderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdrawErcErcOrder(inner) => {
                    <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::acceptErcErcOrder(inner) => {
                    <acceptErcErcOrderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ercErcOrders(inner) => {
                    <ercErcOrdersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOpenOrders(inner) => {
                    <getOpenOrdersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTrustedForwarder(inner) => {
                    <getTrustedForwarderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isTrustedForwarder(inner) => {
                    <isTrustedForwarderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextOrderId(inner) => {
                    <nextOrderIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::placeErcErcOrder(inner) => {
                    <placeErcErcOrderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawErcErcOrder(inner) => {
                    <withdrawErcErcOrderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MarketPlace`](self) events.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum MarketPlaceEvents {
        #[allow(missing_docs)]
        acceptOrder(acceptOrder),
        #[allow(missing_docs)]
        placeOrder(placeOrder),
        #[allow(missing_docs)]
        withdrawOrder(withdrawOrder),
    }
    #[automatically_derived]
    impl MarketPlaceEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                1u8, 31u8, 207u8, 111u8, 197u8, 63u8, 199u8, 153u8, 113u8, 201u8, 233u8,
                63u8, 154u8, 220u8, 237u8, 108u8, 31u8, 39u8, 35u8, 23u8, 123u8, 75u8,
                146u8, 190u8, 134u8, 16u8, 43u8, 5u8, 88u8, 251u8, 176u8, 56u8,
            ],
            [
                196u8, 4u8, 106u8, 48u8, 92u8, 89u8, 237u8, 178u8, 71u8, 46u8, 99u8,
                138u8, 40u8, 206u8, 219u8, 22u8, 86u8, 60u8, 138u8, 160u8, 164u8, 248u8,
                250u8, 255u8, 202u8, 239u8, 28u8, 67u8, 162u8, 111u8, 136u8, 108u8,
            ],
            [
                251u8, 121u8, 27u8, 11u8, 144u8, 183u8, 74u8, 98u8, 167u8, 208u8, 57u8,
                88u8, 51u8, 98u8, 180u8, 190u8, 36u8, 75u8, 7u8, 34u8, 114u8, 98u8, 35u8,
                35u8, 148u8, 233u8, 35u8, 193u8, 100u8, 136u8, 237u8, 49u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MarketPlaceEvents {
        const NAME: &'static str = "MarketPlaceEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<acceptOrder as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <acceptOrder as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::acceptOrder)
                }
                Some(<placeOrder as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <placeOrder as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::placeOrder)
                }
                Some(<withdrawOrder as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <withdrawOrder as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::withdrawOrder)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MarketPlaceEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::acceptOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::placeOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::withdrawOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::acceptOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::placeOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::withdrawOrder(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MarketPlace`](self) contract instance.

See the [wrapper's documentation](`MarketPlaceInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> MarketPlaceInstance<P, N> {
        MarketPlaceInstance::<P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        erc2771Forwarder: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MarketPlaceInstance<P, N>>,
    > {
        MarketPlaceInstance::<P, N>::deploy(provider, erc2771Forwarder)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        erc2771Forwarder: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        MarketPlaceInstance::<P, N>::deploy_builder(provider, erc2771Forwarder)
    }
    /**A [`MarketPlace`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MarketPlace`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MarketPlaceInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for MarketPlaceInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MarketPlaceInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MarketPlaceInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`MarketPlace`](self) contract instance.

See the [wrapper's documentation](`MarketPlaceInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
            erc2771Forwarder: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<MarketPlaceInstance<P, N>> {
            let call_builder = Self::deploy_builder(provider, erc2771Forwarder);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            provider: P,
            erc2771Forwarder: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            erc2771Forwarder,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> MarketPlaceInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MarketPlaceInstance<P, N> {
            MarketPlaceInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MarketPlaceInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`acceptErcErcOrder`] function.
        pub fn acceptErcErcOrder(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
            saleAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, acceptErcErcOrderCall, N> {
            self.call_builder(
                &acceptErcErcOrderCall {
                    id,
                    saleAmount,
                },
            )
        }
        ///Creates a new call builder for the [`ercErcOrders`] function.
        pub fn ercErcOrders(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, ercErcOrdersCall, N> {
            self.call_builder(&ercErcOrdersCall(_0))
        }
        ///Creates a new call builder for the [`getOpenOrders`] function.
        pub fn getOpenOrders(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getOpenOrdersCall, N> {
            self.call_builder(&getOpenOrdersCall)
        }
        ///Creates a new call builder for the [`getTrustedForwarder`] function.
        pub fn getTrustedForwarder(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getTrustedForwarderCall, N> {
            self.call_builder(&getTrustedForwarderCall)
        }
        ///Creates a new call builder for the [`isTrustedForwarder`] function.
        pub fn isTrustedForwarder(
            &self,
            forwarder: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isTrustedForwarderCall, N> {
            self.call_builder(
                &isTrustedForwarderCall {
                    forwarder,
                },
            )
        }
        ///Creates a new call builder for the [`nextOrderId`] function.
        pub fn nextOrderId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextOrderIdCall, N> {
            self.call_builder(&nextOrderIdCall)
        }
        ///Creates a new call builder for the [`placeErcErcOrder`] function.
        pub fn placeErcErcOrder(
            &self,
            sellingToken: alloy::sol_types::private::Address,
            saleAmount: alloy::sol_types::private::primitives::aliases::U256,
            buyingToken: alloy::sol_types::private::Address,
            buyAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, placeErcErcOrderCall, N> {
            self.call_builder(
                &placeErcErcOrderCall {
                    sellingToken,
                    saleAmount,
                    buyingToken,
                    buyAmount,
                },
            )
        }
        ///Creates a new call builder for the [`withdrawErcErcOrder`] function.
        pub fn withdrawErcErcOrder(
            &self,
            id: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawErcErcOrderCall, N> {
            self.call_builder(&withdrawErcErcOrderCall { id })
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MarketPlaceInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`acceptOrder`] event.
        pub fn acceptOrder_filter(&self) -> alloy_contract::Event<&P, acceptOrder, N> {
            self.event_filter::<acceptOrder>()
        }
        ///Creates a new event filter for the [`placeOrder`] event.
        pub fn placeOrder_filter(&self) -> alloy_contract::Event<&P, placeOrder, N> {
            self.event_filter::<placeOrder>()
        }
        ///Creates a new event filter for the [`withdrawOrder`] event.
        pub fn withdrawOrder_filter(
            &self,
        ) -> alloy_contract::Event<&P, withdrawOrder, N> {
            self.event_filter::<withdrawOrder>()
        }
    }
}
